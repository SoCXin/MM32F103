; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\bsp -I..\bsp\test -I..\bsp\usblib -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\uart -I..\..\..\..\..\Device\MM32F103\Include -I..\HARDWARE\KEY -I..\..\..\..\..\Device\CMSIS\KEIL_CORE -IF:\work\8月\F103n、F031n样例制作\MM32F103RegLib_MiniBoard_Ver1.0.0\MM32F103RegLib_MiniBoard_libReg\MBF103PF_reg\USB\USB_Keyboard\KEIL_PRJ\RTE\_projectgroup -IC:\Keil_v5\ARM\PACK\MindMotion\MM32F103_DFP\1.4.3\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\MindMotion\MM32L3xx_DFP\1.0.3\Device\MM32L3xx\Include -D__UVISION_VERSION=522 -DMM32F103CBT -DF103_N_VERSION --omf_browse=.\objects\uart.crf ..\SYSTEM\uart\uart.c]
                          THUMB

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;33     //定义_sys_exit()以避免使用半主机模式    
;;;34     _sys_exit(int x) 
000000  4601              MOV      r1,r0
;;;35     { 
;;;36         x = x; 
000002  bf00              NOP      
;;;37     } 
000004  4770              BX       lr
;;;38     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;38     //重定义fputc函数 
;;;39     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L2.2|
;;;40     {      
;;;41         while((UART1->CSR&0x0001)==0);//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L2.24|
000004  6812              LDR      r2,[r2,#0]
000006  f0020201          AND      r2,r2,#1
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L2.2|
;;;42         UART1->TDR = (ch & (uint16_t)0x00FF);      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L2.24|
000012  3b08              SUBS     r3,r3,#8
000014  601a              STR      r2,[r3,#0]
;;;43         return ch;
;;;44     }
000016  4770              BX       lr
;;;45     
                          ENDP

                  |L2.24|
                          DCD      0x40013808

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;49     
;;;50     void uart_init(u32 pclk2,u32 bound)
000000  b510              PUSH     {r4,lr}
;;;51     {  	 
;;;52         
;;;53         u32 tempBaud;	
;;;54         
;;;55         //-------------------------------------------------
;;;56         RCC->APB2ENR|=1<<2;   //使能GPIOA时钟   #define RCC_APB2Periph_UART1            ((uint32_t)0x00004000) #define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
000002  4b19              LDR      r3,|L3.104|
000004  699b              LDR      r3,[r3,#0x18]
000006  f0430304          ORR      r3,r3,#4
00000a  4c17              LDR      r4,|L3.104|
00000c  61a3              STR      r3,[r4,#0x18]
;;;57         /*
;;;58         APB2外设时钟使能寄存器（RCC_APB2ENR）
;;;59         偏移地址：0x18
;;;60         复位值：0x0000 0000
;;;61         访问：无等待周期，字，半字和字节访问
;;;62         注：当外设时钟没有启动时，软件不能读出外设寄存器的数值	
;;;63         位2
;;;64         IOPAEN：IO端口A时钟使能
;;;65         由软件置’1’或清’0’
;;;66         0：IO端口A时钟关闭；
;;;67         1：IO端口A时钟开启。	
;;;68         */
;;;69         RCC->APB2ENR|=1<<14;  //使能串口时钟 
00000e  4623              MOV      r3,r4
000010  699b              LDR      r3,[r3,#0x18]
000012  f4434380          ORR      r3,r3,#0x4000
000016  61a3              STR      r3,[r4,#0x18]
;;;70         /*
;;;71         位14
;;;72         UART1EN：UART1时钟使能
;;;73         由软件置’1’或清’0’
;;;74         0：UART1时钟关闭；
;;;75         1：UART1时钟开启。	
;;;76         */
;;;77         GPIOA->CRH&=0XFFFFF00F;//IO状态设置
000018  4b14              LDR      r3,|L3.108|
00001a  681b              LDR      r3,[r3,#0]
00001c  f423637f          BIC      r3,r3,#0xff0
000020  4c12              LDR      r4,|L3.108|
000022  6023              STR      r3,[r4,#0]
;;;78         GPIOA->CRH|=0X000008B0;//IO状态设置
000024  4623              MOV      r3,r4
000026  681b              LDR      r3,[r3,#0]
000028  f443630b          ORR      r3,r3,#0x8b0
00002c  6023              STR      r3,[r4,#0]
;;;79         /*
;;;80         8.2.2 端口配置高寄存器（GPIOx_CRH）(x=A..E)
;;;81         偏移地址：0x04
;;;82         复位值：0x4444 4444
;;;83         配置PA9为 B = 10 11  MODE9[1:0] = 11[5:4] ：输出模式，最大速度50MHz, CNF9[1:0] = 10[7:6] ：复用功能推挽输出模式
;;;84         配置PA10 为8 = 10 00 MODE10[1:0] = 00[9:8] ：输入模式（复位后的状态）, CNF10[1:0] = 10[7:6] ：10：上拉/下拉输入模式
;;;85         
;;;86         MODEy[1:0]:端口x的模式位（y=8…15）
;;;87         软件通过这些位配置相应的I/O端口，请参考表15端口位配置表
;;;88         00：输入模式（复位后的状态）
;;;89         01：输出模式，最大速度10MHz
;;;90         10：输出模式，最大速度20MHz
;;;91         11：输出模式，最大速度50MHz
;;;92         
;;;93         CNFy[1:0]:端口x配置位（8…15）
;;;94         软件通过这些位配置相应的I/O端口，请参考表15端口位配置表。
;;;95         在输入模式（MODE[1:0]==00）:
;;;96         00：模拟输入模式
;;;97         01：浮空输入模式
;;;98         10：上拉/下拉输入模式
;;;99         11：保留
;;;100        在输出模式（MODE[1:0]>00）:
;;;101        00：通用推挽输出模式
;;;102        01：通用开漏输出模式
;;;103        10：复用功能推挽输出模式
;;;104        11：复用功能开漏输出模式
;;;105        
;;;106        */	
;;;107        RCC->APB2RSTR|=1<<14;   //复位串口1
00002e  4b0e              LDR      r3,|L3.104|
000030  68db              LDR      r3,[r3,#0xc]
000032  f4434380          ORR      r3,r3,#0x4000
000036  4c0c              LDR      r4,|L3.104|
000038  60e3              STR      r3,[r4,#0xc]
;;;108        RCC->APB2RSTR&=~(1<<14);//停止复位	   	   
00003a  4623              MOV      r3,r4
00003c  68db              LDR      r3,[r3,#0xc]
00003e  f4234380          BIC      r3,r3,#0x4000
000042  60e3              STR      r3,[r4,#0xc]
;;;109        //-------------------------------------------------	
;;;110        //波特率设置
;;;111        // 	UART1->BRR=mantissa; // 波特率设置	 
;;;112        /* Determine the uart_baud*/
;;;113        tempBaud = (pclk2*1000000 / 16) /(bound);
000044  4b0a              LDR      r3,|L3.112|
000046  4343              MULS     r3,r0,r3
000048  091b              LSRS     r3,r3,#4
00004a  fbb3f2f1          UDIV     r2,r3,r1
;;;114        /* Write to UART BRR */
;;;115        UART1->BRR = tempBaud;
00004e  4b09              LDR      r3,|L3.116|
000050  601a              STR      r2,[r3,#0]
;;;116        UART1->CCR|=0X30;  //1位停止,无校验位.
000052  1f1b              SUBS     r3,r3,#4
000054  681b              LDR      r3,[r3,#0]
000056  f0430330          ORR      r3,r3,#0x30
00005a  4c06              LDR      r4,|L3.116|
00005c  1f24              SUBS     r4,r4,#4
00005e  6023              STR      r3,[r4,#0]
;;;117        //-------------------------------------------------	
;;;118        //使能接收中断 
;;;119        UART1->GCR = 0X19;			//收发使能	UART1->CCR|=1<<5;    //接收缓冲区非空中断使能	
000060  2319              MOVS     r3,#0x19
000062  1f24              SUBS     r4,r4,#4
000064  6023              STR      r3,[r4,#0]
;;;120        /*
;;;121        23.5.5 UART 中断使能寄存器(UART_IER)
;;;122        偏移地址：0x10
;;;123        复位值：0x0000
;;;124        位1
;;;125        RXIEN:接收缓冲中断使能位
;;;126        1=中断使能
;;;127        0=中断禁止	
;;;128        23.5.6 UART 中断清除寄存器(UART_ICR)
;;;129        偏移地址：0x14
;;;130        复位值：0x0000
;;;131        位1
;;;132        RXICLR: 接收中断清除位
;;;133        1=中断清除
;;;134        0=中断没有清除
;;;135        */
;;;136    }
000066  bd10              POP      {r4,pc}
;;;137    
                          ENDP

                  |L3.104|
                          DCD      0x40021000
                  |L3.108|
                          DCD      0x40010804
                  |L3.112|
                          DCD      0x000f4240
                  |L3.116|
                          DCD      0x40013820

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\uart\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_9275e5e5____REV16|
#line 129 "..\\..\\..\\..\\..\\Device\\CMSIS\\KEIL_CORE\\core_cmInstr.h"
|__asm___6_uart_c_9275e5e5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_9275e5e5____REVSH|
#line 144
|__asm___6_uart_c_9275e5e5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_9275e5e5____RRX|
#line 300
|__asm___6_uart_c_9275e5e5____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
