; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\sys.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sys.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\bsp -I..\bsp\test -I..\bsp\usblib -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\uart -I..\..\..\..\..\Device\MM32F103\Include -I..\HARDWARE\KEY -I..\..\..\..\..\Device\CMSIS\KEIL_CORE -IF:\work\8月\F103n、F031n样例制作\MM32F103RegLib_MiniBoard_Ver1.0.0\MM32F103RegLib_MiniBoard_libReg\MBF103PF_reg\USB\USB_Keyboard\KEIL_PRJ\RTE\_projectgroup -IC:\Keil_v5\ARM\PACK\MindMotion\MM32F103_DFP\1.4.3\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\MindMotion\MM32L3xx_DFP\1.0.3\Device\MM32L3xx\Include -D__UVISION_VERSION=522 -DMM32F103CBT -DF103_N_VERSION --omf_browse=.\objects\sys.crf ..\SYSTEM\sys\sys.c]
                          THUMB

                          AREA ||i.Ex_NVIC_Config||, CODE, READONLY, ALIGN=2

                  Ex_NVIC_Config PROC
;;;57     //该函数会自动开启对应中断,以及屏蔽线   	    
;;;58     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
000000  b570              PUSH     {r4-r6,lr}
;;;59     {
000002  4604              MOV      r4,r0
;;;60         u8 EXTADDR;
;;;61         u8 EXTOFFSET;
;;;62         EXTADDR=BITx/4;//得到中断寄存器组的编号
000004  460b              MOV      r3,r1
000006  17ce              ASRS     r6,r1,#31
000008  eb017696          ADD      r6,r1,r6,LSR #30
00000c  f3c60087          UBFX     r0,r6,#2,#8
;;;63         EXTOFFSET=(BITx%4)*4; 
000010  17ce              ASRS     r6,r1,#31
000012  eb017696          ADD      r6,r1,r6,LSR #30
000016  10b6              ASRS     r6,r6,#2
000018  eba10686          SUB      r6,r1,r6,LSL #2
00001c  06b6              LSLS     r6,r6,#26
00001e  0e35              LSRS     r5,r6,#24
;;;64         RCC->APB2ENR|=0x01;//使能io复用时钟			 
000020  4b1c              LDR      r3,|L1.148|
000022  699b              LDR      r3,[r3,#0x18]
000024  f0430301          ORR      r3,r3,#1
000028  4e1a              LDR      r6,|L1.148|
00002a  61b3              STR      r3,[r6,#0x18]
;;;65         AFIO->EXTICR[EXTADDR]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
00002c  ea4f33b6          ROR      r3,r6,#14
000030  f8533020          LDR      r3,[r3,r0,LSL #2]
000034  260f              MOVS     r6,#0xf
000036  40ae              LSLS     r6,r6,r5
000038  43b3              BICS     r3,r3,r6
00003a  4e17              LDR      r6,|L1.152|
00003c  f8463020          STR      r3,[r6,r0,LSL #2]
;;;66         AFIO->EXTICR[EXTADDR]|=GPIOx<<EXTOFFSET;//EXTI.BITx映射到GPIOx.BITx 
000040  4633              MOV      r3,r6
000042  f8533020          LDR      r3,[r3,r0,LSL #2]
000046  fa04f605          LSL      r6,r4,r5
00004a  431e              ORRS     r6,r6,r3
00004c  4b12              LDR      r3,|L1.152|
00004e  f8436020          STR      r6,[r3,r0,LSL #2]
;;;67         //自动设置
;;;68         EXTI->IMR|=1<<BITx;//  开启line BITx上的中断
000052  4b12              LDR      r3,|L1.156|
000054  681b              LDR      r3,[r3,#0]
000056  2601              MOVS     r6,#1
000058  408e              LSLS     r6,r6,r1
00005a  4333              ORRS     r3,r3,r6
00005c  4e0f              LDR      r6,|L1.156|
00005e  6033              STR      r3,[r6,#0]
;;;69         //EXTI->EMR|=1<<BITx;//不屏蔽line BITx上的事件 (如果不屏蔽这句,在硬件上是可以的,但是在软件仿真的时候无法进入中断!)
;;;70         if(TRIM&0x01)EXTI->FTSR|=1<<BITx;//line BITx上事件下降沿触发
000060  f0020301          AND      r3,r2,#1
000064  b143              CBZ      r3,|L1.120|
000066  4b0d              LDR      r3,|L1.156|
000068  330c              ADDS     r3,r3,#0xc
00006a  681b              LDR      r3,[r3,#0]
00006c  2601              MOVS     r6,#1
00006e  408e              LSLS     r6,r6,r1
000070  4333              ORRS     r3,r3,r6
000072  4e0a              LDR      r6,|L1.156|
000074  360c              ADDS     r6,r6,#0xc
000076  6033              STR      r3,[r6,#0]
                  |L1.120|
;;;71         if(TRIM&0x02)EXTI->RTSR|=1<<BITx;//line BITx上事件上升降沿触发
000078  f0020302          AND      r3,r2,#2
00007c  b143              CBZ      r3,|L1.144|
00007e  4b07              LDR      r3,|L1.156|
000080  3308              ADDS     r3,r3,#8
000082  681e              LDR      r6,[r3,#0]
000084  2301              MOVS     r3,#1
000086  408b              LSLS     r3,r3,r1
000088  431e              ORRS     r6,r6,r3
00008a  4b04              LDR      r3,|L1.156|
00008c  3308              ADDS     r3,r3,#8
00008e  601e              STR      r6,[r3,#0]
                  |L1.144|
;;;72     } 	  
000090  bd70              POP      {r4-r6,pc}
;;;73     //不能在这里执行所有外设复位!否则至少引起串口不工作.		    
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x40021000
                  |L1.152|
                          DCD      0x40010008
                  |L1.156|
                          DCD      0x40010400

                          AREA ||i.INTX_DISABLE||, CODE, READONLY, ALIGN=1

                  INTX_DISABLE PROC
;;;102    //关闭所有中断
;;;103    void INTX_DISABLE(void)
000000  b672              CPSID    i
;;;104    {		  
;;;105        __ASM volatile("cpsid i");
;;;106    }
000002  4770              BX       lr
;;;107    //开启所有中断
                          ENDP


                          AREA ||i.INTX_ENABLE||, CODE, READONLY, ALIGN=1

                  INTX_ENABLE PROC
;;;107    //开启所有中断
;;;108    void INTX_ENABLE(void)
000000  b662              CPSIE    i
;;;109    {
;;;110        __ASM volatile("cpsie i");		  
;;;111    }
000002  4770              BX       lr
;;;112    
                          ENDP


                          AREA ||i.JTAG_Set||, CODE, READONLY, ALIGN=2

                  JTAG_Set PROC
;;;133    //#define JTAG_SWD_ENABLE    0X00		  
;;;134    void JTAG_Set(u8 mode)
000000  4601              MOV      r1,r0
;;;135    {
;;;136        u32 temp;
;;;137        temp=mode;
;;;138        temp<<=25;
000002  0649              LSLS     r1,r1,#25
;;;139        RCC->APB2ENR|=RCC_APB2RSTR_AFIORST;     //开启辅助时钟	   
000004  4a08              LDR      r2,|L4.40|
000006  6992              LDR      r2,[r2,#0x18]
000008  f0420201          ORR      r2,r2,#1
00000c  4b06              LDR      r3,|L4.40|
00000e  619a              STR      r2,[r3,#0x18]
;;;140        AFIO->MAPR&=0XF8FFFFFF; //清除MAPR的[26:24]
000010  4a06              LDR      r2,|L4.44|
000012  6852              LDR      r2,[r2,#4]
000014  f02262e0          BIC      r2,r2,#0x7000000
000018  4b04              LDR      r3,|L4.44|
00001a  605a              STR      r2,[r3,#4]
;;;141        AFIO->MAPR|=temp;       //设置jtag模式
00001c  461a              MOV      r2,r3
00001e  6852              LDR      r2,[r2,#4]
000020  430a              ORRS     r2,r2,r1
000022  605a              STR      r2,[r3,#4]
;;;142    } 
000024  4770              BX       lr
;;;143    //系统时钟初始化函数
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40021000
                  |L4.44|
                          DCD      0x40010000

                          AREA ||i.MYRCC_DeInit||, CODE, READONLY, ALIGN=2

                  MYRCC_DeInit PROC
;;;74     //把所有时钟寄存器复位		  
;;;75     void MYRCC_DeInit(void)
000000  b500              PUSH     {lr}
;;;76     {	
;;;77         RCC->APB1RSTR = 0x00000000;//复位结束			 
000002  2000              MOVS     r0,#0
000004  4915              LDR      r1,|L5.92|
000006  6108              STR      r0,[r1,#0x10]
;;;78         RCC->APB2RSTR = 0x00000000; 
000008  60c8              STR      r0,[r1,#0xc]
;;;79         
;;;80         RCC->AHBENR = 0x00000014;  //睡眠模式闪存和SRAM时钟使能.其他关闭.	  
00000a  2014              MOVS     r0,#0x14
00000c  6148              STR      r0,[r1,#0x14]
;;;81         RCC->APB2ENR = 0x00000000; //外设时钟关闭.			   
00000e  2000              MOVS     r0,#0
000010  6188              STR      r0,[r1,#0x18]
;;;82         RCC->APB1ENR = 0x00000000;   
000012  61c8              STR      r0,[r1,#0x1c]
;;;83         RCC->CR |= 0x00000001;     //使能内部高速时钟HSION	 															 
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f0400001          ORR      r0,r0,#1
00001c  6008              STR      r0,[r1,#0]
;;;84         RCC->CFGR &= 0xF8FF0000;   //复位SW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]					 
00001e  4608              MOV      r0,r1
000020  6840              LDR      r0,[r0,#4]
000022  490f              LDR      r1,|L5.96|
000024  4008              ANDS     r0,r0,r1
000026  490d              LDR      r1,|L5.92|
000028  6048              STR      r0,[r1,#4]
;;;85         RCC->CR &= 0xFEF6FFFF;     //复位HSEON,CSSON,PLLON
00002a  4608              MOV      r0,r1
00002c  6800              LDR      r0,[r0,#0]
00002e  490d              LDR      r1,|L5.100|
000030  4008              ANDS     r0,r0,r1
000032  490a              LDR      r1,|L5.92|
000034  6008              STR      r0,[r1,#0]
;;;86         RCC->CR &= 0xFFFBFFFF;     //复位HSEBYP	   	  
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  f4202080          BIC      r0,r0,#0x40000
00003e  6008              STR      r0,[r1,#0]
;;;87         RCC->CFGR &= 0xFF80FFFF;   //复位PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE 
000040  4608              MOV      r0,r1
000042  6840              LDR      r0,[r0,#4]
000044  f42000fe          BIC      r0,r0,#0x7f0000
000048  6048              STR      r0,[r1,#4]
;;;88         RCC->CIR = 0x00000000;     //关闭所有中断		 
00004a  2000              MOVS     r0,#0
00004c  6088              STR      r0,[r1,#8]
;;;89         //配置向量表				  
;;;90     #ifdef  VECT_TAB_RAM
;;;91         MY_NVIC_SetVectorTable(0x20000000, 0x0);
;;;92     #else   
;;;93         MY_NVIC_SetVectorTable(0x08000000,0x0);
00004e  2100              MOVS     r1,#0
000050  f04f6000          MOV      r0,#0x8000000
000054  f7fffffe          BL       MY_NVIC_SetVectorTable
;;;94     #endif
;;;95     }
000058  bd00              POP      {pc}
;;;96     //THUMB指令不支持汇编内联
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      0x40021000
                  |L5.96|
                          DCD      0xf8ff0000
                  |L5.100|
                          DCD      0xfef6ffff

                          AREA ||i.MY_NVIC_Init||, CODE, READONLY, ALIGN=2

                  MY_NVIC_Init PROC
;;;39     //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;40     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;41     { 
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;42         u32 temp;	
;;;43         MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;44         temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000012  f1c50004          RSB      r0,r5,#4
000016  fa07f600          LSL      r6,r7,r0
;;;45         temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
00001a  200f              MOVS     r0,#0xf
00001c  4128              ASRS     r0,r0,r5
00001e  ea000008          AND      r0,r0,r8
000022  4306              ORRS     r6,r6,r0
;;;46         temp&=0xf;								//取低四位  
000024  f006060f          AND      r6,r6,#0xf
;;;47         NVIC->ISER[NVIC_Channel/32]|=(1<<NVIC_Channel%32);//使能中断位(要清除的话,相反操作就OK) 
000028  17e2              ASRS     r2,r4,#31
00002a  eb0462d2          ADD      r2,r4,r2,LSR #27
00002e  1152              ASRS     r2,r2,#5
000030  0092              LSLS     r2,r2,#2
000032  f10222e0          ADD      r2,r2,#0xe000e000
000036  f8d22100          LDR      r2,[r2,#0x100]
00003a  4621              MOV      r1,r4
00003c  17e3              ASRS     r3,r4,#31
00003e  eb0463d3          ADD      r3,r4,r3,LSR #27
000042  115b              ASRS     r3,r3,#5
000044  eba41c43          SUB      r12,r4,r3,LSL #5
000048  2301              MOVS     r3,#1
00004a  fa03f30c          LSL      r3,r3,r12
00004e  431a              ORRS     r2,r2,r3
000050  4620              MOV      r0,r4
000052  17e3              ASRS     r3,r4,#31
000054  eb0463d3          ADD      r3,r4,r3,LSR #27
000058  115b              ASRS     r3,r3,#5
00005a  009b              LSLS     r3,r3,#2
00005c  f10323e0          ADD      r3,r3,#0xe000e000
000060  f8c32100          STR      r2,[r3,#0x100]
;;;48         NVIC->IP[NVIC_Channel]|=temp<<4;		//设置响应优先级和抢断优先级   	    	  				   
000064  4803              LDR      r0,|L6.116|
000066  5d00              LDRB     r0,[r0,r4]
000068  ea401006          ORR      r0,r0,r6,LSL #4
00006c  4901              LDR      r1,|L6.116|
00006e  5508              STRB     r0,[r1,r4]
;;;49     } 
000070  e8bd81f0          POP      {r4-r8,pc}
;;;50     //外部中断配置函数
                          ENDP

                  |L6.116|
                          DCD      0xe000e400

                          AREA ||i.MY_NVIC_PriorityGroupConfig||, CODE, READONLY, ALIGN=2

                  MY_NVIC_PriorityGroupConfig PROC
;;;15     //NVIC_Group:NVIC分组 0~4 总共5组 		   
;;;16     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
000000  4601              MOV      r1,r0
;;;17     { 
;;;18         u32 temp,temp1;	  
;;;19         temp1=(~NVIC_Group)&0x07;//取后三位
000002  2307              MOVS     r3,#7
000004  ea230201          BIC      r2,r3,r1
;;;20         temp1<<=8;
000008  0212              LSLS     r2,r2,#8
;;;21         temp=SCB->AIRCR;  //读取先前的设置
00000a  4b05              LDR      r3,|L7.32|
00000c  6818              LDR      r0,[r3,#0]
;;;22         temp&=0X0000F8FF; //清空先前分组
00000e  f64f03ff          MOV      r3,#0xf8ff
000012  4018              ANDS     r0,r0,r3
;;;23         temp|=0X05FA0000; //写入钥匙
000014  4b03              LDR      r3,|L7.36|
000016  4318              ORRS     r0,r0,r3
;;;24         temp|=temp1;	   
000018  4310              ORRS     r0,r0,r2
;;;25         SCB->AIRCR=temp;  //设置分组	    	  				   
00001a  4b01              LDR      r3,|L7.32|
00001c  6018              STR      r0,[r3,#0]
;;;26     }
00001e  4770              BX       lr
;;;27     //设置NVIC 
                          ENDP

                  |L7.32|
                          DCD      0xe000ed0c
                  |L7.36|
                          DCD      0x05fa0000

                          AREA ||i.MY_NVIC_SetVectorTable||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;8      //Offset:偏移量			 
;;;9      void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
000000  4a02              LDR      r2,|L8.12|
;;;10     { 	   	 
;;;11         SCB->VTOR = NVIC_VectTab|(Offset & (u32)0x1FFFFF80);//设置NVIC的向量表偏移寄存器
000002  400a              ANDS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  4b02              LDR      r3,|L8.16|
000008  601a              STR      r2,[r3,#0]
;;;12         //用于标识向量表是在CODE区还是在RAM区
;;;13     }
00000a  4770              BX       lr
;;;14     //设置NVIC分组
                          ENDP

                  |L8.12|
                          DCD      0x1fffff80
                  |L8.16|
                          DCD      0xe000ed08

                          AREA ||i.Sys_Soft_Reset||, CODE, READONLY, ALIGN=2

                  Sys_Soft_Reset PROC
;;;124    //系统软复位   
;;;125    void Sys_Soft_Reset(void)
000000  4801              LDR      r0,|L9.8|
;;;126    {   
;;;127        SCB->AIRCR =0X05FA0000|(u32)0x04;	  
000002  4902              LDR      r1,|L9.12|
000004  6008              STR      r0,[r1,#0]
;;;128    } 		 
000006  4770              BX       lr
;;;129    //JTAG模式设置,用于设置JTAG的模式
                          ENDP

                  |L9.8|
                          DCD      0x05fa0004
                  |L9.12|
                          DCD      0xe000ed0c

                          AREA ||i.Sys_Standby||, CODE, READONLY, ALIGN=2

                  Sys_Standby PROC
;;;114    //进入待机模式	  
;;;115    void Sys_Standby(void)
000000  b500              PUSH     {lr}
;;;116    {
;;;117        SCB->SCR|=SCB_SCR_SLEEPDEEP;//使能SLEEPDEEP位 (SYS->CTRL)	   
000002  480f              LDR      r0,|L10.64|
000004  6800              LDR      r0,[r0,#0]
000006  f0400004          ORR      r0,r0,#4
00000a  490d              LDR      r1,|L10.64|
00000c  6008              STR      r0,[r1,#0]
;;;118        RCC->APB1ENR|=RCC_APB1RSTR_PWRRST;     //使能电源时钟	    
00000e  480d              LDR      r0,|L10.68|
000010  69c0              LDR      r0,[r0,#0x1c]
000012  f0405080          ORR      r0,r0,#0x10000000
000016  490b              LDR      r1,|L10.68|
000018  61c8              STR      r0,[r1,#0x1c]
;;;119        PWR->CSR|=PWR_CSR_EWUP;          //设置WKUP用于唤醒
00001a  480b              LDR      r0,|L10.72|
00001c  6840              LDR      r0,[r0,#4]
00001e  f4407080          ORR      r0,r0,#0x100
000022  4909              LDR      r1,|L10.72|
000024  6048              STR      r0,[r1,#4]
;;;120        PWR->CR|=PWR_CR_CWUF;           //清除Wake-up 标志
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f0400004          ORR      r0,r0,#4
00002e  6008              STR      r0,[r1,#0]
;;;121        PWR->CR|=PWR_CR_PDDS;           //PDDS置位		  
000030  4608              MOV      r0,r1
000032  6800              LDR      r0,[r0,#0]
000034  f0400002          ORR      r0,r0,#2
000038  6008              STR      r0,[r1,#0]
;;;122        WFI_SET();				 //执行WFI指令		 
00003a  f7fffffe          BL       WFI_SET
;;;123    }	     
00003e  bd00              POP      {pc}
;;;124    //系统软复位   
                          ENDP

                  |L10.64|
                          DCD      0xe000ed10
                  |L10.68|
                          DCD      0x40021000
                  |L10.72|
                          DCD      0x40007000

                          AREA ||i.SystemClk_Output||, CODE, READONLY, ALIGN=2

                  SystemClk_Output PROC
;;;185    #endif
;;;186    void SystemClk_Output(void)
000000  481b              LDR      r0,|L11.112|
;;;187    {
;;;188        
;;;189        //	GPIO_InitTypeDef  GPIO_InitStructure;
;;;190        //	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
;;;191        //	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8;   //mco  pa8
;;;192        //	GPIO_InitStructure.GPIO_Speed =  GPIO_Speed_50MHz;
;;;193        //  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 推免复用输出
;;;194        //	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;195        
;;;196        RCC->APB2ENR|=RCC_APB2ENR_IOPAEN;    //使能GPIOA时钟	   	 
000002  6980              LDR      r0,[r0,#0x18]
000004  f0400004          ORR      r0,r0,#4
000008  4919              LDR      r1,|L11.112|
00000a  6188              STR      r0,[r1,#0x18]
;;;197        GPIOA->CRH&=0XFFFFFFF0; 
00000c  4819              LDR      r0,|L11.116|
00000e  6800              LDR      r0,[r0,#0]
000010  f020000f          BIC      r0,r0,#0xf
000014  4917              LDR      r1,|L11.116|
000016  6008              STR      r0,[r1,#0]
;;;198        GPIOA->CRH|=GPIO_CRH_MODE8;//PA8 推挽输出   	 
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0400003          ORR      r0,r0,#3
000020  6008              STR      r0,[r1,#0]
;;;199        GPIOA->ODR|=GPIO_ODR_ODR8;      //PA8 输出高
000022  4814              LDR      r0,|L11.116|
000024  3008              ADDS     r0,r0,#8
000026  6800              LDR      r0,[r0,#0]
000028  f4407080          ORR      r0,r0,#0x100
00002c  4911              LDR      r1,|L11.116|
00002e  3108              ADDS     r1,r1,#8
000030  6008              STR      r0,[r1,#0]
;;;200        
;;;201        
;;;202        //------------------------------------------------------------
;;;203        //add start
;;;204        /*
;;;205    #define  RCC_CFGR_MCO_2                      ((uint32_t)0x04000000)   
;;;206        位26:24
;;;207        MCO： 微控制器时钟输出
;;;208        由软件置’1’或清零。
;;;209        00x：没有时钟输出；
;;;210        010：LSI 时钟输出；
;;;211        011：LSE 时钟输出；
;;;212        100：系统时钟(SYSCLK)输出；
;;;213        101：HSI 时钟输出；
;;;214        110：HSE 时钟输出；
;;;215        111：PLL 时钟2分频后输出。
;;;216        注意：
;;;217        - 该时钟输出在启动和切换MCO时钟源时可能会被截断。
;;;218        - 在系统时钟作为输出至MCO管脚时，请保证输出时钟频率不超过50MHz (IO口最高频率)
;;;219        */ 
;;;220        
;;;221        //	RCC->CR &= (uint32_t)~RCC_CFGR_MCO;  //CLEAR pll PARAMETERS
;;;222        //-------------------------------------------------	 
;;;223        //	RCC->CFGR |= (uint32_t)RCC_CFGR_MCO_PLL ;//PLL/2
;;;224        if(SystemCoreClock<8000000){
000032  4811              LDR      r0,|L11.120|
000034  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000036  4911              LDR      r1,|L11.124|
000038  4288              CMP      r0,r1
00003a  d206              BCS      |L11.74|
;;;225            //RCC_MCOConfig(RCC_MCO_HSE);  //通过PA8 pin 观察频率
;;;226            RCC->CFGR |= (uint32_t)RCC_CFGR_MCO_HSE ;//PLL/2
00003c  480c              LDR      r0,|L11.112|
00003e  6840              LDR      r0,[r0,#4]
000040  f04060c0          ORR      r0,r0,#0x6000000
000044  490a              LDR      r1,|L11.112|
000046  6048              STR      r0,[r1,#4]
000048  e011              B        |L11.110|
                  |L11.74|
;;;227        }
;;;228        else if(SystemCoreClock<=48000000){
00004a  480b              LDR      r0,|L11.120|
00004c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00004e  490c              LDR      r1,|L11.128|
000050  4288              CMP      r0,r1
000052  d806              BHI      |L11.98|
;;;229            //RCC_MCOConfig(RCC_MCO_SYSCLK);  //通过PA8 pin 观察频率 SYSCLK<48M
;;;230            RCC->CFGR |= (uint32_t)RCC_CFGR_MCO_SYSCLK ;//PLL/2
000054  4806              LDR      r0,|L11.112|
000056  6840              LDR      r0,[r0,#4]
000058  f0406080          ORR      r0,r0,#0x4000000
00005c  4904              LDR      r1,|L11.112|
00005e  6048              STR      r0,[r1,#4]
000060  e005              B        |L11.110|
                  |L11.98|
;;;231        }
;;;232        else{
;;;233            //RCC_MCOConfig(RCC_MCO_PLLCLK_Div2);  //通过PA8 pin 观察频率
;;;234            RCC->CFGR |= (uint32_t)RCC_CFGR_MCO_PLL ;//PLL/2
000062  4803              LDR      r0,|L11.112|
000064  6840              LDR      r0,[r0,#4]
000066  f04060e0          ORR      r0,r0,#0x7000000
00006a  4901              LDR      r1,|L11.112|
00006c  6048              STR      r0,[r1,#4]
                  |L11.110|
;;;235        }
;;;236    }
00006e  4770              BX       lr
;;;237    
                          ENDP

                  |L11.112|
                          DCD      0x40021000
                  |L11.116|
                          DCD      0x40010804
                  |L11.120|
                          DCD      SystemCoreClock
                  |L11.124|
                          DCD      0x007a1200
                  |L11.128|
                          DCD      0x02dc6c00

                          AREA ||i.System_Clock_Init||, CODE, READONLY, ALIGN=2

                  System_Clock_Init PROC
;;;144    //pll:选择的倍频数，从2开始，最大值为16		 
;;;145    void System_Clock_Init(u8 PLL)
000000  b530              PUSH     {r4,r5,lr}
;;;146    {
000002  4605              MOV      r5,r0
;;;147        unsigned char temp=0;   
000004  2400              MOVS     r4,#0
;;;148        MYRCC_DeInit();		  //复位并配置向量表
000006  f7fffffe          BL       MYRCC_DeInit
;;;149        RCC->CR|=RCC_CR_HSEON;  //外部高速时钟使能HSEON
00000a  4825              LDR      r0,|L12.160|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4403080          ORR      r0,r0,#0x10000
000012  4923              LDR      r1,|L12.160|
000014  6008              STR      r0,[r1,#0]
;;;150        while(!(RCC->CR&RCC_CR_HSERDY));//等待外部时钟就绪
000016  bf00              NOP      
                  |L12.24|
000018  4821              LDR      r0,|L12.160|
00001a  6800              LDR      r0,[r0,#0]
00001c  f4003000          AND      r0,r0,#0x20000
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L12.24|
;;;151        RCC->CFGR=RCC_CFGR_PPRE1_2; //APB1=DIV2;APB2=DIV1;AHB=DIV1;
000024  f44f6080          MOV      r0,#0x400
000028  491d              LDR      r1,|L12.160|
00002a  6048              STR      r0,[r1,#4]
;;;152        
;;;153        RCC->CFGR|=RCC_CFGR_PLLSRC;	  //PLLSRC ON 
00002c  4608              MOV      r0,r1
00002e  6840              LDR      r0,[r0,#4]
000030  f4403080          ORR      r0,r0,#0x10000
000034  6048              STR      r0,[r1,#4]
;;;154        RCC->CR &=~(RCC_CR_PLLON);		//清PLL//	RCC->CR &=~(7<<20);		//清PLL
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  f0207080          BIC      r0,r0,#0x1000000
00003e  6008              STR      r0,[r1,#0]
;;;155        
;;;156        RCC->CR &=~(0x1f<<26);	
000040  4608              MOV      r0,r1
000042  6800              LDR      r0,[r0,#0]
000044  f02040f8          BIC      r0,r0,#0x7c000000
000048  6008              STR      r0,[r1,#0]
;;;157        RCC->CR|=(PLL - 1) << 26;   //设置PLL值 2~16
00004a  4608              MOV      r0,r1
00004c  6801              LDR      r1,[r0,#0]
00004e  1e68              SUBS     r0,r5,#1
000050  ea416080          ORR      r0,r1,r0,LSL #26
000054  4912              LDR      r1,|L12.160|
000056  6008              STR      r0,[r1,#0]
;;;158        
;;;159        FLASH->ACR|=FLASH_ACR_LATENCY_1|FLASH_ACR_PRFTBE|FLASH_ACR_PRFTBS;	  //FLASH 2个延时周期
000058  4812              LDR      r0,|L12.164|
00005a  6800              LDR      r0,[r0,#0]
00005c  f0400032          ORR      r0,r0,#0x32
000060  4910              LDR      r1,|L12.164|
000062  6008              STR      r0,[r1,#0]
;;;160        
;;;161        RCC->CR|=RCC_CR_PLLON;  //PLLON
000064  480e              LDR      r0,|L12.160|
000066  6800              LDR      r0,[r0,#0]
000068  f0407080          ORR      r0,r0,#0x1000000
00006c  490c              LDR      r1,|L12.160|
00006e  6008              STR      r0,[r1,#0]
;;;162        while(!(RCC->CR&RCC_CR_PLLRDY));//等待PLL锁定
000070  bf00              NOP      
                  |L12.114|
000072  480b              LDR      r0,|L12.160|
000074  6800              LDR      r0,[r0,#0]
000076  f0007000          AND      r0,r0,#0x2000000
00007a  2800              CMP      r0,#0
00007c  d0f9              BEQ      |L12.114|
;;;163        RCC->CFGR|=RCC_CFGR_SW_PLL;//PLL作为系统时钟	 
00007e  4808              LDR      r0,|L12.160|
000080  6840              LDR      r0,[r0,#4]
000082  f0400002          ORR      r0,r0,#2
000086  4906              LDR      r1,|L12.160|
000088  6048              STR      r0,[r1,#4]
;;;164        while(temp!=0x02)     //等待PLL作为系统时钟设置成功
00008a  e005              B        |L12.152|
                  |L12.140|
;;;165        {    
;;;166            temp=RCC->CFGR>>2;
00008c  4804              LDR      r0,|L12.160|
00008e  6840              LDR      r0,[r0,#4]
000090  f3c00487          UBFX     r4,r0,#2,#8
;;;167            temp&=0x03;
000094  f0040403          AND      r4,r4,#3
                  |L12.152|
000098  2c02              CMP      r4,#2                 ;164
00009a  d1f7              BNE      |L12.140|
;;;168        }    
;;;169        
;;;170    }		    
00009c  bd30              POP      {r4,r5,pc}
;;;171    /*
                          ENDP

00009e  0000              DCW      0x0000
                  |L12.160|
                          DCD      0x40021000
                  |L12.164|
                          DCD      0x40022000

                          AREA ||i.WFI_SET||, CODE, READONLY, ALIGN=1

                  WFI_SET PROC
;;;97     //采用如下方法实现执行汇编指令WFI  
;;;98     void WFI_SET(void)
000000  bf30              WFI      
;;;99     {
;;;100        __ASM volatile("wfi");		  
;;;101    }
000002  4770              BX       lr
;;;102    //关闭所有中断
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\sys\\sys.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_d144038c____REV16|
#line 129 "..\\..\\..\\..\\..\\Device\\CMSIS\\KEIL_CORE\\core_cmInstr.h"
|__asm___5_sys_c_d144038c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_d144038c____REVSH|
#line 144
|__asm___5_sys_c_d144038c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_d144038c____RRX|
#line 300
|__asm___5_sys_c_d144038c____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
