; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\bulkusb.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bulkusb.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\bsp -I..\bsp\test -I..\bsp\usblib -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\uart -I..\..\..\..\..\Device\MM32F103\Include -I..\HARDWARE\KEY -I..\..\..\..\..\Device\CMSIS\KEIL_CORE -IF:\work\8月\F103n、F031n样例制作\MM32F103RegLib_MiniBoard_Ver1.0.0\MM32F103RegLib_MiniBoard_libReg\MBF103PF_reg\USB\USB_Keyboard\KEIL_PRJ\RTE\_projectgroup -IC:\Keil_v5\ARM\PACK\MindMotion\MM32F103_DFP\1.4.3\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\MindMotion\MM32L3xx_DFP\1.0.3\Device\MM32L3xx\Include -D__UVISION_VERSION=522 -DMM32F103CBT -DF103_N_VERSION --omf_browse=.\objects\bulkusb.crf ..\bsp\usblib\bulkusb.c]
                          THUMB

                          AREA ||i.Deal_Trans_Items||, CODE, READONLY, ALIGN=2

                  Deal_Trans_Items PROC
;;;27     
;;;28     void Deal_Trans_Items( void)
000000  b510              PUSH     {r4,lr}
;;;29     {
;;;30         switch( CBWCB[0] )
000002  4839              LDR      r0,|L1.232|
000004  7800              LDRB     r0,[r0,#0]  ; CBWCB
000006  2828              CMP      r0,#0x28
000008  d02c              BEQ      |L1.100|
00000a  dc10              BGT      |L1.46|
00000c  281a              CMP      r0,#0x1a
00000e  d02d              BEQ      |L1.108|
000010  dc06              BGT      |L1.32|
000012  2800              CMP      r0,#0
000014  d056              BEQ      |L1.196|
000016  2803              CMP      r0,#3
000018  d01b              BEQ      |L1.82|
00001a  2812              CMP      r0,#0x12
00001c  d157              BNE      |L1.206|
00001e  e015              B        |L1.76|
                  |L1.32|
000020  281e              CMP      r0,#0x1e
000022  d050              BEQ      |L1.198|
000024  2823              CMP      r0,#0x23
000026  d017              BEQ      |L1.88|
000028  2825              CMP      r0,#0x25
00002a  d150              BNE      |L1.206|
00002c  e017              B        |L1.94|
                  |L1.46|
00002e  28aa              CMP      r0,#0xaa
000030  d027              BEQ      |L1.130|
000032  dc06              BGT      |L1.66|
000034  282a              CMP      r0,#0x2a
000036  d01c              BEQ      |L1.114|
000038  282f              CMP      r0,#0x2f
00003a  d045              BEQ      |L1.200|
00003c  28a8              CMP      r0,#0xa8
00003e  d146              BNE      |L1.206|
000040  e01b              B        |L1.122|
                  |L1.66|
000042  28b8              CMP      r0,#0xb8
000044  d031              BEQ      |L1.170|
000046  28ba              CMP      r0,#0xba
000048  d141              BNE      |L1.206|
00004a  e01e              B        |L1.138|
                  |L1.76|
;;;31         {
;;;32         case    INQUIRY_OPCODE :    							// 0x12
;;;33             {
;;;34                 ScsiCmdInquiry( ) ;
00004c  f7fffffe          BL       ScsiCmdInquiry
;;;35                 break ;
000050  e047              B        |L1.226|
                  |L1.82|
;;;36             }
;;;37         case    REQUEST_SENSE_OPCODE:    					// 0x03
;;;38             {
;;;39                 ScsiCmdRequestSense( ) ;
000052  f7fffffe          BL       ScsiCmdRequestSense
;;;40                 break ;
000056  e044              B        |L1.226|
                  |L1.88|
;;;41             }
;;;42         case    _23_OPCODE :        							// 0x23
;;;43             {
;;;44                 _op_code_23_handle( ) ;
000058  f7fffffe          BL       _op_code_23_handle
;;;45                 break ;
00005c  e041              B        |L1.226|
                  |L1.94|
;;;46             }
;;;47         case    READ_CAPACITY10_OPCODE :    					// 0x25
;;;48             {
;;;49                 _read_capacity_handle( ) ;
00005e  f7fffffe          BL       _read_capacity_handle
;;;50                 break ;
000062  e03e              B        |L1.226|
                  |L1.100|
;;;51             }
;;;52         case    READ10_OPCODE :             					// 0x28
;;;53             {
;;;54                 _read10_handle(TRUE) ;
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       _read10_handle
;;;55                 break ;
00006a  e03a              B        |L1.226|
                  |L1.108|
;;;56             }
;;;57         case    MODE_SENSE6_OPCODE :        					// 0x1A
;;;58             {
;;;59                 _sense6_handle( ) ;
00006c  f7fffffe          BL       _sense6_handle
;;;60                 break ;
000070  e037              B        |L1.226|
                  |L1.114|
;;;61             }
;;;62         case    WRITE10_OPCODE :            					// 0x2A
;;;63             {
;;;64                 _write10_handle(TRUE);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       _write10_handle
;;;65                 break ;
000078  e033              B        |L1.226|
                  |L1.122|
;;;66             }
;;;67         case    READTEST_OPCODE :             					// 0xA8
;;;68             {
;;;69                 _read10_handle(FALSE) ;
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       _read10_handle
;;;70                 break ;
000080  e02f              B        |L1.226|
                  |L1.130|
;;;71             }
;;;72         case    WRITETEST_OPCODE :            				// 0xAA
;;;73             {		
;;;74                 _write10_handle(FALSE);
000082  2000              MOVS     r0,#0
000084  f7fffffe          BL       _write10_handle
;;;75                 break ;
000088  e02b              B        |L1.226|
                  |L1.138|
;;;76             }
;;;77         case    STALLOUT_OPCODE :            				// 0xB8
;;;78             {		
;;;79                 USB->rEP_HALT = 1<<EPOUT;
00008a  2004              MOVS     r0,#4
00008c  4917              LDR      r1,|L1.236|
00008e  6008              STR      r0,[r1,#0]
;;;80                 USB_SEND_OPEN_STALL[EPOUT]=TRUE;
000090  2001              MOVS     r0,#1
000092  4917              LDR      r1,|L1.240|
000094  7088              STRB     r0,[r1,#2]
;;;81     #ifdef UART_PRINTF
;;;82                 uart_printf( "EP enable out stall Cmd, 0x%x\r\n", CBWCB[0] ) ;
;;;83     #endif 
;;;84                 usb_running_state = USB_IDLE ;
000096  20ff              MOVS     r0,#0xff
000098  4916              LDR      r1,|L1.244|
00009a  7008              STRB     r0,[r1,#0]
;;;85                 p_recv_buf = (uint32)usb_cbw_buf;
00009c  4816              LDR      r0,|L1.248|
00009e  4917              LDR      r1,|L1.252|
0000a0  6008              STR      r0,[r1,#0]  ; p_recv_buf
;;;86                 recv_residue = sizeof(usb_cbw_buf);
0000a2  201f              MOVS     r0,#0x1f
0000a4  4916              LDR      r1,|L1.256|
0000a6  6008              STR      r0,[r1,#0]  ; recv_residue
;;;87                 break ;
0000a8  e01b              B        |L1.226|
                  |L1.170|
;;;88             }
;;;89             
;;;90         case    STALLIN_OPCODE :            				// 0xBA
;;;91             {		
;;;92                 USB_SEND_OPEN_STALL[EPIN]=TRUE;
0000aa  2001              MOVS     r0,#1
0000ac  4910              LDR      r1,|L1.240|
0000ae  7048              STRB     r0,[r1,#1]
;;;93     #ifdef UART_PRINTF
;;;94                 uart_printf( "EP enable In stall Cmd, 0x%x\r\n", CBWCB[0] ) ;
;;;95     #endif 
;;;96                 usb_running_state = USB_IDLE ;
0000b0  20ff              MOVS     r0,#0xff
0000b2  4910              LDR      r1,|L1.244|
0000b4  7008              STRB     r0,[r1,#0]
;;;97                 p_recv_buf = (uint32)usb_cbw_buf;
0000b6  4810              LDR      r0,|L1.248|
0000b8  4910              LDR      r1,|L1.252|
0000ba  6008              STR      r0,[r1,#0]  ; p_recv_buf
;;;98                 recv_residue = sizeof(usb_cbw_buf);
0000bc  201f              MOVS     r0,#0x1f
0000be  4910              LDR      r1,|L1.256|
0000c0  6008              STR      r0,[r1,#0]  ; recv_residue
;;;99                 
;;;100                break ;
0000c2  e00e              B        |L1.226|
                  |L1.196|
;;;101            }
;;;102            
;;;103        case    TEST_UNIT_READY_OPCODE :    					// 0x00
;;;104        case    PREVENT_REMOVAL_OPCODE :    					// 0x1E
0000c4  bf00              NOP      
                  |L1.198|
;;;105        case    VERIFY10_OPCODE :           					// 0x2F    
0000c6  bf00              NOP      
                  |L1.200|
;;;106            {
;;;107                _cmd_common_handle( ) ;
0000c8  f7fffffe          BL       _cmd_common_handle
;;;108                break ;
0000cc  e009              B        |L1.226|
                  |L1.206|
;;;109            }                
;;;110        default :
;;;111            {
;;;112    #ifdef UART_PRINTF
;;;113                uart_printf( "Unknown Cmd, 0x%x\r\n", CBWCB[0] ) ;
;;;114    #endif 
;;;115    #ifdef USB_EP_STALL_TEST
;;;116                
;;;117                USB->rEP_HALT = (1<<EPOUT);
;;;118                USB_SEND_OPEN_STALL[EPOUT] = TRUE;
;;;119    #endif
;;;120                
;;;121                usb_running_state = USB_IDLE ;			
0000ce  20ff              MOVS     r0,#0xff
0000d0  4908              LDR      r1,|L1.244|
0000d2  7008              STRB     r0,[r1,#0]
;;;122                p_recv_buf = (uint32)usb_cbw_buf;
0000d4  4808              LDR      r0,|L1.248|
0000d6  4909              LDR      r1,|L1.252|
0000d8  6008              STR      r0,[r1,#0]  ; p_recv_buf
;;;123                recv_residue = sizeof(usb_cbw_buf);
0000da  201f              MOVS     r0,#0x1f
0000dc  4908              LDR      r1,|L1.256|
0000de  6008              STR      r0,[r1,#0]  ; recv_residue
;;;124                break;
0000e0  bf00              NOP      
                  |L1.226|
0000e2  bf00              NOP                            ;35
;;;125            }
;;;126        }    
;;;127    }
0000e4  bd10              POP      {r4,pc}
;;;128    // ==================================== Low Sub Feature ===================================
                          ENDP

0000e6  0000              DCW      0x0000
                  |L1.232|
                          DCD      CBWCB
                  |L1.236|
                          DCD      0x40005d88
                  |L1.240|
                          DCD      USB_SEND_OPEN_STALL
                  |L1.244|
                          DCD      usb_running_state
                  |L1.248|
                          DCD      usb_cbw_buf
                  |L1.252|
                          DCD      p_recv_buf
                  |L1.256|
                          DCD      recv_residue

                          AREA ||i.device_rx_fifo||, CODE, READONLY, ALIGN=2

                  device_rx_fifo PROC
;;;280    
;;;281    uint32 device_rx_fifo(uint32 dstAddr, uint32 byteCnt,uint32 bDMAmode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;282    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;283        uint32 count;
;;;284        for( count = 0; count < byteCnt; count++ )
00000a  2600              MOVS     r6,#0
00000c  e008              B        |L2.32|
                  |L2.14|
;;;285        {
;;;286            //		uint8 val = read_mreg8(USB_EPn_FIFO(EPOUT));
;;;287            uint8 val = USB->rEP2_FIFO;
00000e  4807              LDR      r0,|L2.44|
000010  6800              LDR      r0,[r0,#0]
000012  b2c7              UXTB     r7,r0
;;;288            write_mreg8(dstAddr,val);
000014  4639              MOV      r1,r7
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       write_mreg8
;;;289            dstAddr++;
00001c  1c64              ADDS     r4,r4,#1
00001e  1c76              ADDS     r6,r6,#1              ;284
                  |L2.32|
000020  42ae              CMP      r6,r5                 ;284
000022  d3f4              BCC      |L2.14|
;;;290        }
;;;291        
;;;292        return dstAddr;
000024  4620              MOV      r0,r4
;;;293    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;294    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x40005d68

                          AREA ||i.device_tx_fifo||, CODE, READONLY, ALIGN=2

                  device_tx_fifo PROC
;;;294    
;;;295    uint32 device_tx_fifo(uint32 srcAddr, uint32 byteCnt, uint32 bDMAmode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;296    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;297        uint32 count;
;;;298        
;;;299        
;;;300        while(USB->rEP1_CTRL&0x80);
00000a  bf00              NOP      
                  |L3.12|
00000c  480c              LDR      r0,|L3.64|
00000e  6800              LDR      r0,[r0,#0]
000010  f0000080          AND      r0,r0,#0x80
000014  2800              CMP      r0,#0
000016  d1f9              BNE      |L3.12|
;;;301        for( count = 0; count < byteCnt; count++)
000018  2500              MOVS     r5,#0
00001a  e008              B        |L3.46|
                  |L3.28|
;;;302        {
;;;303            uint8 val = read_mreg8(srcAddr);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       read_mreg8
000022  4607              MOV      r7,r0
;;;304            //write_mreg8(USB_EPn_FIFO(EPIN),val);
;;;305            USB->rEP2_FIFO = val;
000024  4806              LDR      r0,|L3.64|
000026  3024              ADDS     r0,r0,#0x24
000028  6007              STR      r7,[r0,#0]
;;;306            srcAddr++;
00002a  1c76              ADDS     r6,r6,#1
00002c  1c6d              ADDS     r5,r5,#1              ;301
                  |L3.46|
00002e  42a5              CMP      r5,r4                 ;301
000030  d3f4              BCC      |L3.28|
;;;307        }
;;;308        USB->rEP1_CTRL = 0x80|byteCnt;
000032  f0440080          ORR      r0,r4,#0x80
000036  4902              LDR      r1,|L3.64|
000038  6008              STR      r0,[r1,#0]
;;;309        return srcAddr;
00003a  4630              MOV      r0,r6
;;;310    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;311    
                          ENDP

                  |L3.64|
                          DCD      0x40005d44

                          AREA ||i.usb_bulk_in_token_handle||, CODE, READONLY, ALIGN=1

                  usb_bulk_in_token_handle PROC
;;;202    
;;;203    void usb_bulk_in_token_handle( void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205        Deal_Trans_Items( ) ;
000002  f7fffffe          BL       Deal_Trans_Items
;;;206    }
000006  bd10              POP      {r4,pc}
;;;207    void usb_bulk_out_handle( void)
                          ENDP


                          AREA ||i.usb_bulk_out_handle||, CODE, READONLY, ALIGN=1

                  usb_bulk_out_handle PROC
;;;206    }
;;;207    void usb_bulk_out_handle( void)
000000  b510              PUSH     {r4,lr}
;;;208    {
;;;209        Deal_Trans_Items( ) ;
000002  f7fffffe          BL       Deal_Trans_Items
;;;210    }
000006  bd10              POP      {r4,pc}
;;;211    void usb_bulk_trans_finish_handle( void)
                          ENDP


                          AREA ||i.usb_bulk_trans_finish_handle||, CODE, READONLY, ALIGN=1

                  usb_bulk_trans_finish_handle PROC
;;;210    }
;;;211    void usb_bulk_trans_finish_handle( void)
000000  b510              PUSH     {r4,lr}
;;;212    {
;;;213        Deal_Trans_Items( ) ;
000002  f7fffffe          BL       Deal_Trans_Items
;;;214    }
000006  bd10              POP      {r4,pc}
;;;215    // =============================== usb IN OUT main fature ==========================
                          ENDP


                          AREA ||i.usb_cbw_handle||, CODE, READONLY, ALIGN=2

                  usb_cbw_handle PROC
;;;128    // ==================================== Low Sub Feature ===================================
;;;129    void usb_cbw_handle( void)
000000  b510              PUSH     {r4,lr}
;;;130    {
;;;131        
;;;132        uint32 cnt = MIN(recv_residue,EPn_MAX_PACKAGE_SIZE);
000002  480e              LDR      r0,|L7.60|
000004  6800              LDR      r0,[r0,#0]  ; recv_residue
000006  2840              CMP      r0,#0x40
000008  d202              BCS      |L7.16|
00000a  480c              LDR      r0,|L7.60|
00000c  6800              LDR      r0,[r0,#0]  ; recv_residue
00000e  e000              B        |L7.18|
                  |L7.16|
000010  2040              MOVS     r0,#0x40
                  |L7.18|
000012  4604              MOV      r4,r0
;;;133    #ifdef USB_CBWCSW_DMA_MODE	
;;;134        p_recv_buf = device_rx_fifo(p_recv_buf,cnt,TRUE);
;;;135    #else
;;;136        p_recv_buf = device_rx_fifo(p_recv_buf,cnt,FALSE);
000014  2200              MOVS     r2,#0
000016  4621              MOV      r1,r4
000018  4809              LDR      r0,|L7.64|
00001a  6800              LDR      r0,[r0,#0]  ; p_recv_buf
00001c  f7fffffe          BL       device_rx_fifo
000020  4907              LDR      r1,|L7.64|
000022  6008              STR      r0,[r1,#0]  ; p_recv_buf
;;;137    #endif
;;;138        recv_residue -= cnt;
000024  4805              LDR      r0,|L7.60|
000026  6800              LDR      r0,[r0,#0]  ; recv_residue
000028  1b00              SUBS     r0,r0,r4
00002a  4904              LDR      r1,|L7.60|
00002c  6008              STR      r0,[r1,#0]  ; recv_residue
;;;139        if(recv_residue == 0)
00002e  4608              MOV      r0,r1
000030  6800              LDR      r0,[r0,#0]  ; recv_residue
000032  b908              CBNZ     r0,|L7.56|
;;;140        {
;;;141            usb_deal_cbw();
000034  f7fffffe          BL       usb_deal_cbw
                  |L7.56|
;;;142        }
;;;143    }
000038  bd10              POP      {r4,pc}
;;;144    
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      recv_residue
                  |L7.64|
                          DCD      p_recv_buf

                          AREA ||i.usb_deal_cbw||, CODE, READONLY, ALIGN=2

                  usb_deal_cbw PROC
;;;144    
;;;145    void usb_deal_cbw(void)
000000  b538              PUSH     {r3-r5,lr}
;;;146    {
;;;147        uint8   cbw_ix;
;;;148        uint8   dCBWSigCont[4] = { 0x55, 0x53, 0x42, 0x43 } ;   	// USBC dCBWSignature
000002  a030              ADR      r0,|L8.196|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;149        uint8   error_flag = 0 ;
000008  2500              MOVS     r5,#0
;;;150        //***********************************************//
;;;151        //Table 5.1 Command Block Wrapper
;;;152        //***********************************************//	
;;;153        //read dCBWSignature byte[3]--byte[0]
;;;154        for( cbw_ix = 0; cbw_ix <= 3; cbw_ix++ )  
00000a  2400              MOVS     r4,#0
00000c  e006              B        |L8.28|
                  |L8.14|
;;;155        {
;;;156            dCBWSig[cbw_ix-0] = usb_cbw_buf[cbw_ix];
00000e  482e              LDR      r0,|L8.200|
000010  5d00              LDRB     r0,[r0,r4]
000012  4621              MOV      r1,r4
000014  4a2d              LDR      r2,|L8.204|
000016  5450              STRB     r0,[r2,r1]
000018  1c60              ADDS     r0,r4,#1              ;154
00001a  b2c4              UXTB     r4,r0                 ;154
                  |L8.28|
00001c  2c03              CMP      r4,#3                 ;154
00001e  ddf6              BLE      |L8.14|
;;;157        }
;;;158        //read dCBWTag byte[7]--byte[4]
;;;159        for( cbw_ix = 4; cbw_ix <= 7; cbw_ix++ )  
000020  2404              MOVS     r4,#4
000022  e006              B        |L8.50|
                  |L8.36|
;;;160        {
;;;161            dCBWTag[cbw_ix-4] = usb_cbw_buf[cbw_ix];
000024  4828              LDR      r0,|L8.200|
000026  5d01              LDRB     r1,[r0,r4]
000028  1f20              SUBS     r0,r4,#4
00002a  4a29              LDR      r2,|L8.208|
00002c  5411              STRB     r1,[r2,r0]
00002e  1c60              ADDS     r0,r4,#1              ;159
000030  b2c4              UXTB     r4,r0                 ;159
                  |L8.50|
000032  2c07              CMP      r4,#7                 ;159
000034  ddf6              BLE      |L8.36|
;;;162        }
;;;163        //read dCBWDataTRansferLength byte[11]--byte[8]
;;;164        for( cbw_ix = 8; cbw_ix <= 11; cbw_ix++ )  
000036  2408              MOVS     r4,#8
000038  e007              B        |L8.74|
                  |L8.58|
;;;165        {
;;;166            bmCBWDataLength[cbw_ix-8] = usb_cbw_buf[cbw_ix];
00003a  4823              LDR      r0,|L8.200|
00003c  5d01              LDRB     r1,[r0,r4]
00003e  f1a40008          SUB      r0,r4,#8
000042  4a24              LDR      r2,|L8.212|
000044  5411              STRB     r1,[r2,r0]
000046  1c60              ADDS     r0,r4,#1              ;164
000048  b2c4              UXTB     r4,r0                 ;164
                  |L8.74|
00004a  2c0b              CMP      r4,#0xb               ;164
00004c  ddf5              BLE      |L8.58|
;;;167        }
;;;168        //read bmCBWFlags byte[12]
;;;169        bmCBWFlag = usb_cbw_buf[12];
00004e  481e              LDR      r0,|L8.200|
000050  7b00              LDRB     r0,[r0,#0xc]  ; usb_cbw_buf
000052  4921              LDR      r1,|L8.216|
000054  7008              STRB     r0,[r1,#0]
;;;170        //read bCBWLUN byte[13]
;;;171        bCBWLUN = usb_cbw_buf[13];
000056  481c              LDR      r0,|L8.200|
000058  7b40              LDRB     r0,[r0,#0xd]  ; usb_cbw_buf
00005a  4920              LDR      r1,|L8.220|
00005c  7008              STRB     r0,[r1,#0]
;;;172        //read bCBWCBLength byte[14]
;;;173        bCBWCBLength = usb_cbw_buf[14];								//valid data is 1--16
00005e  481a              LDR      r0,|L8.200|
000060  7b80              LDRB     r0,[r0,#0xe]  ; usb_cbw_buf
000062  491f              LDR      r1,|L8.224|
000064  7008              STRB     r0,[r1,#0]
;;;174        //read CBWCB byte[30]--byte[15]
;;;175        for( cbw_ix = 15; cbw_ix <= 30; cbw_ix++ ) 
000066  240f              MOVS     r4,#0xf
000068  e007              B        |L8.122|
                  |L8.106|
;;;176        {
;;;177            CBWCB[cbw_ix-15] = usb_cbw_buf[cbw_ix];
00006a  4817              LDR      r0,|L8.200|
00006c  5d01              LDRB     r1,[r0,r4]
00006e  f1a4000f          SUB      r0,r4,#0xf
000072  4a1c              LDR      r2,|L8.228|
000074  5411              STRB     r1,[r2,r0]
000076  1c60              ADDS     r0,r4,#1              ;175
000078  b2c4              UXTB     r4,r0                 ;175
                  |L8.122|
00007a  2c1e              CMP      r4,#0x1e              ;175
00007c  ddf5              BLE      |L8.106|
;;;178        }
;;;179        //judge correct or wrong
;;;180        for( cbw_ix = 0; cbw_ix < 4; cbw_ix++ )  
00007e  2400              MOVS     r4,#0
000080  e008              B        |L8.148|
                  |L8.130|
;;;181        {
;;;182            if( dCBWSigCont[cbw_ix] != dCBWSig[cbw_ix] )    
000082  f81d0004          LDRB     r0,[sp,r4]
000086  4911              LDR      r1,|L8.204|
000088  5d09              LDRB     r1,[r1,r4]
00008a  4288              CMP      r0,r1
00008c  d000              BEQ      |L8.144|
;;;183                error_flag = 1 ;
00008e  2501              MOVS     r5,#1
                  |L8.144|
000090  1c60              ADDS     r0,r4,#1              ;180
000092  b2c4              UXTB     r4,r0                 ;180
                  |L8.148|
000094  2c04              CMP      r4,#4                 ;180
000096  dbf4              BLT      |L8.130|
;;;184        }
;;;185        if( bCBWLUN != 0x00 )   
000098  4810              LDR      r0,|L8.220|
00009a  7800              LDRB     r0,[r0,#0]  ; bCBWLUN
00009c  b100              CBZ      r0,|L8.160|
;;;186        {
;;;187            error_flag = 1 ;
00009e  2501              MOVS     r5,#1
                  |L8.160|
;;;188        }
;;;189        if( error_flag )    
0000a0  b14d              CBZ      r5,|L8.182|
;;;190        {
;;;191    #ifdef UART_PRINTF
;;;192            uart_printf("CBW error!\r\n");
;;;193    #endif
;;;194            usb_running_state = USB_IDLE ;
0000a2  20ff              MOVS     r0,#0xff
0000a4  4910              LDR      r1,|L8.232|
0000a6  7008              STRB     r0,[r1,#0]
;;;195            p_recv_buf = (uint32)usb_cbw_buf;
0000a8  4807              LDR      r0,|L8.200|
0000aa  4910              LDR      r1,|L8.236|
0000ac  6008              STR      r0,[r1,#0]  ; p_recv_buf
;;;196            recv_residue = sizeof(usb_cbw_buf);
0000ae  201f              MOVS     r0,#0x1f
0000b0  490f              LDR      r1,|L8.240|
0000b2  6008              STR      r0,[r1,#0]  ; recv_residue
                  |L8.180|
;;;197            return ;
;;;198        }	
;;;199        usb_running_state = USB_BULK_CBW ;
;;;200        Deal_Trans_Items( ) ;
;;;201    }
0000b4  bd38              POP      {r3-r5,pc}
                  |L8.182|
0000b6  2010              MOVS     r0,#0x10              ;199
0000b8  490b              LDR      r1,|L8.232|
0000ba  7008              STRB     r0,[r1,#0]            ;199
0000bc  f7fffffe          BL       Deal_Trans_Items
0000c0  bf00              NOP      
0000c2  e7f7              B        |L8.180|
;;;202    
                          ENDP

                  |L8.196|
0000c4  55534243          DCB      "USBC"
                  |L8.200|
                          DCD      usb_cbw_buf
                  |L8.204|
                          DCD      dCBWSig
                  |L8.208|
                          DCD      dCBWTag
                  |L8.212|
                          DCD      bmCBWDataLength
                  |L8.216|
                          DCD      bmCBWFlag
                  |L8.220|
                          DCD      bCBWLUN
                  |L8.224|
                          DCD      bCBWCBLength
                  |L8.228|
                          DCD      CBWCB
                  |L8.232|
                          DCD      usb_running_state
                  |L8.236|
                          DCD      p_recv_buf
                  |L8.240|
                          DCD      recv_residue

                          AREA ||i.usb_hid_report_handle||, CODE, READONLY, ALIGN=2

                  usb_hid_report_handle PROC
;;;313    
;;;314    void usb_hid_report_handle()
000000  bf00              NOP      
                  |L9.2|
;;;315    {
;;;316    #ifdef USB_EP_STALL_TEST
;;;317        static uint32 hid_cnt = 1;
;;;318        if(((hid_cnt++)%0x80==0x00))	
;;;319        {
;;;320            
;;;321            USB->rEP_HALT = (1<<(EPIN);
;;;322    #ifndef SCC5_VER_0302				
;;;323                             USB->rEP1_CTRL = 0x80;
;;;324    #endif			
;;;325                             USB_SEND_OPEN_STALL[EPIN] = TRUE;
;;;326        }
;;;327    	else
;;;328    #endif
;;;329    	{
;;;330    #ifdef USB_DMA_MODE
;;;331                
;;;332                uint32 ch;
;;;333                uint32 *hid_val = (uint32*)0x68000000; 					//because it's place at sram which dam can access
;;;334                hid_val[0] = 0x00010100;
;;;335                //usb_dma_tx_start((uint32)hid_val,USB_EPn_FIFO(EPIN),sizeof(hid_val));
;;;336                usb_dma_tx_start((uint32)hid_val,USB->rEP1_FIFO,sizeof(hid_val));
;;;337                
;;;338                ch = (EPIN==USB_EPn(1))?(0):(1);
;;;339                dma_finished_flag[ch] = 0;
;;;340    #ifdef USB_INTR_MODE			
;;;341                while(dma_finished_flag[ch]==0x00);						//wait dma transfer done
;;;342    #else
;;;343                do{
;;;344                    
;;;345                    uint32 temp = USB->rINT_STATE;
;;;346                    if(ch==0)
;;;347                    {
;;;348                        //				if(temp&USB_INT_DMA_CH0) 
;;;349                        //				{
;;;350                        //					dma_finished_flag[0]=1; 					//dma transfer done
;;;351                        //					USB->rINT_STATE = USB_INT_DMA_CH0;
;;;352                        //					break;
;;;353                        //				}
;;;354                    }else
;;;355                    {			
;;;356                        //				if(temp&USB_INT_DMA_CH1) 
;;;357                        //				{
;;;358                        //					dma_finished_flag[1]=1; 					//dma transfer done
;;;359                        //					USB->rINT_STATE = USB_INT_DMA_CH1;
;;;360                        //					break;
;;;361                        //				}
;;;362                    }
;;;363                }while(1);												//wait dma transfer done
;;;364    #endif
;;;365                dma_finished_flag[ch] = 0;
;;;366                usb_dma_close(&usb_dma_tx_cmd);
;;;367    #else
;;;368                
;;;369                while(USB->rEP1_CTRL&0x80);
000002  4803              LDR      r0,|L9.16|
000004  6800              LDR      r0,[r0,#0]
000006  f0000080          AND      r0,r0,#0x80
00000a  2800              CMP      r0,#0
00000c  d1f9              BNE      |L9.2|
;;;370                
;;;371    #endif
;;;372    	}	
;;;373    }
00000e  4770              BX       lr
;;;374                             
                          ENDP

                  |L9.16|
                          DCD      0x40005d44

                          AREA ||i.usb_in_handle||, CODE, READONLY, ALIGN=2

                  usb_in_handle PROC
;;;215    // =============================== usb IN OUT main fature ==========================
;;;216    void usb_in_handle( void)       // IN Request Received
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218        if( usb_ep_flag== USB_EP0 )
000002  4804              LDR      r0,|L10.20|
000004  7800              LDRB     r0,[r0,#0]  ; usb_ep_flag
000006  b910              CBNZ     r0,|L10.14|
;;;219        {
;;;220            ctrl_in_token_handle() ;
000008  f7fffffe          BL       ctrl_in_token_handle
00000c  e001              B        |L10.18|
                  |L10.14|
;;;221        }
;;;222        else 
;;;223        {
;;;224    #ifdef DEVICE_HID
;;;225            usb_hid_report_handle();
00000e  f7fffffe          BL       usb_hid_report_handle
                  |L10.18|
;;;226    #else
;;;227    #ifndef USB_DEVICE_MASS_STORAGE
;;;228            if( usb_running_state == USB_IDLE)
;;;229            {
;;;230                if(USB_SEND_OPEN_STALL[EPIN])
;;;231                {		
;;;232                    USB->rEP_HALT = (1<<EPIN);//all epn except ep0 send stall
;;;233    #ifdef UART_PRINTF
;;;234                    uart_printf( "EP Send in stall Cmd\r\n") ;
;;;235    #endif
;;;236                }
;;;237                else
;;;238                {			
;;;239                    
;;;240                    USB->rEP1_FIFO = 'U';
;;;241                    USB->rEP1_CTRL = 0x81;
;;;242    #ifdef UART_PRINTF
;;;243                    uart_printf( "in@IDLE\r\n") ;
;;;244    #endif
;;;245                }
;;;246            }
;;;247            else
;;;248    #endif 			
;;;249            {
;;;250                usb_bulk_in_token_handle( ) ;
;;;251            }		
;;;252            
;;;253    #endif
;;;254        }
;;;255        
;;;256    }
000012  bd10              POP      {r4,pc}
;;;257    
                          ENDP

                  |L10.20|
                          DCD      usb_ep_flag

                          AREA ||i.usb_out_handle||, CODE, READONLY, ALIGN=2

                  usb_out_handle PROC
;;;257    
;;;258    void usb_out_handle( void)      								// OUT Packet Received
000000  b510              PUSH     {r4,lr}
;;;259    {
;;;260        if( usb_ep_flag == USB_EP0 )
000002  480b              LDR      r0,|L11.48|
000004  7800              LDRB     r0,[r0,#0]  ; usb_ep_flag
000006  b940              CBNZ     r0,|L11.26|
;;;261        {
;;;262            ctrl_out_handle();
000008  f7fffffe          BL       ctrl_out_handle
;;;263            p_recv_buf = (uint32)usb_cbw_buf;
00000c  4809              LDR      r0,|L11.52|
00000e  490a              LDR      r1,|L11.56|
000010  6008              STR      r0,[r1,#0]  ; p_recv_buf
;;;264            recv_residue = sizeof(usb_cbw_buf);		
000012  201f              MOVS     r0,#0x1f
000014  4909              LDR      r1,|L11.60|
000016  6008              STR      r0,[r1,#0]  ; recv_residue
000018  e008              B        |L11.44|
                  |L11.26|
;;;265        }
;;;266        else
;;;267        {
;;;268            if( usb_running_state == USB_IDLE)
00001a  4809              LDR      r0,|L11.64|
00001c  7800              LDRB     r0,[r0,#0]  ; usb_running_state
00001e  28ff              CMP      r0,#0xff
000020  d102              BNE      |L11.40|
;;;269            {
;;;270                usb_cbw_handle();
000022  f7fffffe          BL       usb_cbw_handle
000026  e001              B        |L11.44|
                  |L11.40|
;;;271            }
;;;272            else                       								// Out for bulk trans 
;;;273            {
;;;274                usb_bulk_out_handle();
000028  f7fffffe          BL       usb_bulk_out_handle
                  |L11.44|
;;;275                
;;;276            }
;;;277        }
;;;278        
;;;279    }
00002c  bd10              POP      {r4,pc}
;;;280    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      usb_ep_flag
                  |L11.52|
                          DCD      usb_cbw_buf
                  |L11.56|
                          DCD      p_recv_buf
                  |L11.60|
                          DCD      recv_residue
                  |L11.64|
                          DCD      usb_running_state

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  CBWCB
                          %        16
                  usb_cbw_buf
                          %        31

                          AREA ||.data||, DATA, ALIGN=0

                  dCBWSig
                          DCDU     0x00000000
                  dCBWTag
                          DCDU     0x00000000
                  bmCBWDataLength
                          DCDU     0x00000000
                  bmCBWFlag
00000c  00                DCB      0x00
                  bCBWLUN
00000d  00                DCB      0x00
                  bCBWCBLength
00000e  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\bsp\\usblib\\bulkusb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bulkusb_c_de3e5f6a____REV16|
#line 129 "..\\..\\..\\..\\..\\Device\\CMSIS\\KEIL_CORE\\core_cmInstr.h"
|__asm___9_bulkusb_c_de3e5f6a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bulkusb_c_de3e5f6a____REVSH|
#line 144
|__asm___9_bulkusb_c_de3e5f6a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_bulkusb_c_de3e5f6a____RRX|
#line 300
|__asm___9_bulkusb_c_de3e5f6a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
