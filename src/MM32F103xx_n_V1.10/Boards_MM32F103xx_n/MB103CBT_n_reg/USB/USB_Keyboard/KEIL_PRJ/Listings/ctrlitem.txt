; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ctrlitem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ctrlitem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\bsp -I..\bsp\test -I..\bsp\usblib -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\uart -I..\..\..\..\..\Device\MM32F103\Include -I..\HARDWARE\KEY -I..\..\..\..\..\Device\CMSIS\KEIL_CORE -IF:\work\8月\F103n、F031n样例制作\MM32F103RegLib_MiniBoard_Ver1.0.0\MM32F103RegLib_MiniBoard_libReg\MBF103PF_reg\USB\USB_Keyboard\KEIL_PRJ\RTE\_projectgroup -IC:\Keil_v5\ARM\PACK\MindMotion\MM32F103_DFP\1.4.3\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\MindMotion\MM32L3xx_DFP\1.0.3\Device\MM32L3xx\Include -D__UVISION_VERSION=522 -DMM32F103CBT -DF103_N_VERSION --omf_browse=.\objects\ctrlitem.crf ..\bsp\usblib\ctrlitem.c]
                          THUMB

                          AREA ||i.Chap9_ClearFeature||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Chap9_ClearFeature PROC
;;;380    
;;;381    void Chap9_ClearFeature( void)      							// 0x01
000000  b510              PUSH     {r4,lr}
;;;382    {
;;;383        switch(usb_running_ctrl_state)
000002  481b              LDR      r0,|L1.112|
000004  7800              LDRB     r0,[r0,#0]  ; usb_running_ctrl_state
000006  b110              CBZ      r0,|L1.14|
000008  2801              CMP      r0,#1
00000a  d12b              BNE      |L1.100|
00000c  e027              B        |L1.94|
                  |L1.14|
;;;384        {
;;;385        case    USB_CTRL_SETUP :
;;;386            {
;;;387                if(req_dir == USB_REQ_DIR_OUT)
00000e  4819              LDR      r0,|L1.116|
000010  7800              LDRB     r0,[r0,#0]  ; req_dir
000012  bb00              CBNZ     r0,|L1.86|
;;;388                {
;;;389                    uint8 ix;
;;;390                    if((req_recip==USB_REQ_RECIP_EP)&&(wValue==ENDPOINT_HALT))//ENDPOINT_HALT
000014  4818              LDR      r0,|L1.120|
000016  7800              LDRB     r0,[r0,#0]  ; req_recip
000018  2802              CMP      r0,#2
00001a  d116              BNE      |L1.74|
00001c  4817              LDR      r0,|L1.124|
00001e  8800              LDRH     r0,[r0,#0]  ; wValue
000020  b998              CBNZ     r0,|L1.74|
;;;391                    {
;;;392                        USB->rEP_HALT = 0x00;
000022  2000              MOVS     r0,#0
000024  4916              LDR      r1,|L1.128|
000026  6008              STR      r0,[r1,#0]
;;;393                        
;;;394                        
;;;395                        printf( "Clear EP stall 0x%02X\r\n",USB->rEP_HALT);
000028  4608              MOV      r0,r1
00002a  6801              LDR      r1,[r0,#0]
00002c  a015              ADR      r0,|L1.132|
00002e  f7fffffe          BL       __2printf
;;;396                        for(ix = 0; ix < 5; ix++)
000032  2400              MOVS     r4,#0
000034  e006              B        |L1.68|
                  |L1.54|
;;;397                        {
;;;398                            USB_EP_STALL[ix] = FALSE;
000036  2000              MOVS     r0,#0
000038  4918              LDR      r1,|L1.156|
00003a  5508              STRB     r0,[r1,r4]
;;;399                            USB_SEND_OPEN_STALL[ix] = FALSE;	
00003c  4918              LDR      r1,|L1.160|
00003e  5508              STRB     r0,[r1,r4]
000040  1c60              ADDS     r0,r4,#1              ;396
000042  b2c4              UXTB     r4,r0                 ;396
                  |L1.68|
000044  2c05              CMP      r4,#5                 ;396
000046  dbf6              BLT      |L1.54|
000048  e004              B        |L1.84|
                  |L1.74|
;;;400                        }
;;;401                    }
;;;402                    else if((req_recip==USB_REQ_RECIP_DEV)&&(wValue==DEVICE_REMOTE_WAKEUP))//DEVICE_REMOTE_WAKEUP
00004a  480b              LDR      r0,|L1.120|
00004c  7800              LDRB     r0,[r0,#0]  ; req_recip
00004e  b908              CBNZ     r0,|L1.84|
000050  480a              LDR      r0,|L1.124|
000052  8800              LDRH     r0,[r0,#0]  ; wValue
                  |L1.84|
;;;403                    {
;;;404                        
;;;405                        
;;;406                    }					
;;;407                }
000054  bf00              NOP      
                  |L1.86|
;;;408                else
;;;409                {
;;;410                    
;;;411                }
;;;412                usb_running_ctrl_state = USB_CTRL_IN;
000056  2001              MOVS     r0,#1
000058  4905              LDR      r1,|L1.112|
00005a  7008              STRB     r0,[r1,#0]
;;;413                break;
00005c  e006              B        |L1.108|
                  |L1.94|
;;;414            }
;;;415        case USB_CTRL_IN: 											//status stage
;;;416            {
;;;417                EP0_Send_Empty_Packet();
00005e  f7fffffe          BL       EP0_Send_Empty_Packet
;;;418            }
;;;419        default:
000062  bf00              NOP      
                  |L1.100|
;;;420            {
;;;421                usb_running_ctrl_state = USB_IDLE;
000064  20ff              MOVS     r0,#0xff
000066  4902              LDR      r1,|L1.112|
000068  7008              STRB     r0,[r1,#0]
;;;422                break;
00006a  bf00              NOP      
                  |L1.108|
00006c  bf00              NOP                            ;413
;;;423            }
;;;424        }
;;;425    }
00006e  bd10              POP      {r4,pc}
;;;426    void MLsup_StallEP0( void)          							// reserve      0x02
                          ENDP

                  |L1.112|
                          DCD      usb_running_ctrl_state
                  |L1.116|
                          DCD      req_dir
                  |L1.120|
                          DCD      req_recip
                  |L1.124|
                          DCD      wValue
                  |L1.128|
                          DCD      0x40005d88
                  |L1.132|
000084  436c6561          DCB      "Clear EP stall 0x%02X\r\n",0
000088  72204550
00008c  20737461
000090  6c6c2030
000094  78253032
000098  580d0a00
                  |L1.156|
                          DCD      USB_EP_STALL
                  |L1.160|
                          DCD      USB_SEND_OPEN_STALL

                          AREA ||i.Chap9_GetConfiguration||, CODE, READONLY, ALIGN=2

                  Chap9_GetConfiguration PROC
;;;470    }
;;;471    void Chap9_GetConfiguration( void)								//0x08
000000  b510              PUSH     {r4,lr}
;;;472    {
;;;473        if(req_dir == USB_REQ_DIR_IN)
000002  4803              LDR      r0,|L2.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  2880              CMP      r0,#0x80
000008  d101              BNE      |L2.14|
;;;474        {
;;;475            EP0_Send_Empty_Packet();
00000a  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L2.14|
;;;476        }
;;;477        else
;;;478        {
;;;479            
;;;480        }
;;;481    }
00000e  bd10              POP      {r4,pc}
;;;482    
                          ENDP

                  |L2.16|
                          DCD      req_dir

                          AREA ||i.Chap9_GetDescriptor||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Chap9_GetDescriptor PROC
;;;230    }
;;;231    void Chap9_GetDescriptor( void)     							//0x06
000000  b570              PUSH     {r4-r6,lr}
;;;232    {
;;;233        static uint16    ctrl_buf_ix = 0;
;;;234        
;;;235        switch( usb_running_ctrl_state )
000002  4834              LDR      r0,|L3.212|
000004  7800              LDRB     r0,[r0,#0]  ; usb_running_ctrl_state
000006  b110              CBZ      r0,|L3.14|
000008  2801              CMP      r0,#1
00000a  d15a              BNE      |L3.194|
00000c  e00b              B        |L3.38|
                  |L3.14|
;;;236        {
;;;237        case    USB_CTRL_SETUP :
;;;238            {	
;;;239                Get_Desc_Prepare( ) ;								//发送BUF指针指向待发送数据
00000e  f7fffffe          BL       Get_Desc_Prepare
;;;240                usb_running_ctrl_state = USB_CTRL_IN ;
000012  2001              MOVS     r0,#1
000014  492f              LDR      r1,|L3.212|
000016  7008              STRB     r0,[r1,#0]
;;;241                ctrl_buf_ix = 0;
000018  2000              MOVS     r0,#0
00001a  492f              LDR      r1,|L3.216|
00001c  8008              STRH     r0,[r1,#0]
;;;242                printf( "set up获取描述符\n\r") ;
00001e  a02f              ADR      r0,|L3.220|
000020  f7fffffe          BL       __2printf
;;;243                break ;
000024  e051              B        |L3.202|
                  |L3.38|
;;;244            }
;;;245        case    USB_CTRL_IN :
;;;246            {
;;;247                uint16    count = 0;
000026  2400              MOVS     r4,#0
;;;248                uint16    ix = 0 ;
000028  2500              MOVS     r5,#0
;;;249                
;;;250                printf( "写入缓冲区：") ;
00002a  a031              ADR      r0,|L3.240|
00002c  f7fffffe          BL       __2printf
;;;251                
;;;252                if(wLength>0)										//数据分批发送
000030  4833              LDR      r0,|L3.256|
000032  8800              LDRH     r0,[r0,#0]  ; wLength
000034  2800              CMP      r0,#0
000036  dd33              BLE      |L3.160|
;;;253                {
;;;254                    count = MIN(EP0_MAX_PACKAGE_SIZE,wLength);
000038  4831              LDR      r0,|L3.256|
00003a  8800              LDRH     r0,[r0,#0]  ; wLength
00003c  2840              CMP      r0,#0x40
00003e  dd01              BLE      |L3.68|
000040  2040              MOVS     r0,#0x40
000042  e001              B        |L3.72|
                  |L3.68|
000044  482e              LDR      r0,|L3.256|
000046  8800              LDRH     r0,[r0,#0]  ; wLength
                  |L3.72|
000048  4604              MOV      r4,r0
;;;255                    
;;;256                    while(USB->rEP0_CTRL &0x80);
00004a  bf00              NOP      
                  |L3.76|
00004c  482d              LDR      r0,|L3.260|
00004e  6800              LDR      r0,[r0,#0]
000050  f0000080          AND      r0,r0,#0x80
000054  2800              CMP      r0,#0
000056  d1f9              BNE      |L3.76|
;;;257                    
;;;258                    for(ix=0; ix < count; ix++)
000058  2500              MOVS     r5,#0
00005a  e016              B        |L3.138|
                  |L3.92|
;;;259                    {
;;;260                        printf("%x ",p_ctrl_buf[ctrl_buf_ix]);
00005c  482a              LDR      r0,|L3.264|
00005e  6800              LDR      r0,[r0,#0]  ; p_ctrl_buf
000060  4a1d              LDR      r2,|L3.216|
000062  8812              LDRH     r2,[r2,#0]  ; ctrl_buf_ix
000064  5c81              LDRB     r1,[r0,r2]
000066  a029              ADR      r0,|L3.268|
000068  f7fffffe          BL       __2printf
;;;261                        USB->rEP0_FIFO = p_ctrl_buf[ctrl_buf_ix];
00006c  4826              LDR      r0,|L3.264|
00006e  6800              LDR      r0,[r0,#0]  ; p_ctrl_buf
000070  4919              LDR      r1,|L3.216|
000072  8809              LDRH     r1,[r1,#0]  ; ctrl_buf_ix
000074  5c40              LDRB     r0,[r0,r1]
000076  4923              LDR      r1,|L3.260|
000078  3120              ADDS     r1,r1,#0x20
00007a  6008              STR      r0,[r1,#0]
;;;262                        
;;;263                        ctrl_buf_ix++;
00007c  4816              LDR      r0,|L3.216|
00007e  8800              LDRH     r0,[r0,#0]  ; ctrl_buf_ix
000080  1c40              ADDS     r0,r0,#1
000082  4915              LDR      r1,|L3.216|
000084  8008              STRH     r0,[r1,#0]
000086  1c68              ADDS     r0,r5,#1              ;258
000088  b285              UXTH     r5,r0                 ;258
                  |L3.138|
00008a  42a5              CMP      r5,r4                 ;258
00008c  dbe6              BLT      |L3.92|
;;;264                    }
;;;265                    USB->rEP0_CTRL = count|0x80;
00008e  f0440080          ORR      r0,r4,#0x80
000092  491c              LDR      r1,|L3.260|
000094  6008              STR      r0,[r1,#0]
;;;266                    wLength -= count;
000096  481a              LDR      r0,|L3.256|
000098  8800              LDRH     r0,[r0,#0]  ; wLength
00009a  1b00              SUBS     r0,r0,r4
00009c  4918              LDR      r1,|L3.256|
00009e  8008              STRH     r0,[r1,#0]
                  |L3.160|
;;;267                }			
;;;268                if( wLength == 0)
0000a0  4817              LDR      r0,|L3.256|
0000a2  8800              LDRH     r0,[r0,#0]  ; wLength
0000a4  b948              CBNZ     r0,|L3.186|
;;;269                {
;;;270                    if(count==EP0_MAX_PACKAGE_SIZE)					//发送数据总数为包最大值的整数倍时在末尾帧发送空数据
0000a6  2c40              CMP      r4,#0x40
0000a8  d101              BNE      |L3.174|
;;;271                    {
;;;272                        EP0_Send_Empty_Packet();
0000aa  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L3.174|
;;;273                    }
;;;274                    else
;;;275                    {
;;;276                    }
;;;277                    usb_running_ctrl_state = USB_IDLE;				//数据发送完成
0000ae  20ff              MOVS     r0,#0xff
0000b0  4908              LDR      r1,|L3.212|
0000b2  7008              STRB     r0,[r1,#0]
;;;278                    ctrl_buf_ix = 0;
0000b4  2000              MOVS     r0,#0
0000b6  4908              LDR      r1,|L3.216|
0000b8  8008              STRH     r0,[r1,#0]
                  |L3.186|
;;;279                }
;;;280                printf( "\r\n") ;
0000ba  a015              ADR      r0,|L3.272|
0000bc  f7fffffe          BL       __2printf
;;;281                break ;
0000c0  e003              B        |L3.202|
                  |L3.194|
;;;282            }
;;;283        default :
;;;284            {
;;;285                usb_running_ctrl_state = USB_IDLE ;
0000c2  20ff              MOVS     r0,#0xff
0000c4  4903              LDR      r1,|L3.212|
0000c6  7008              STRB     r0,[r1,#0]
;;;286                break ;
0000c8  bf00              NOP      
                  |L3.202|
0000ca  bf00              NOP                            ;243
;;;287            }
;;;288        }
;;;289        usb_state = USB_STATE_CONFIGURED;
0000cc  2004              MOVS     r0,#4
0000ce  4911              LDR      r1,|L3.276|
0000d0  7008              STRB     r0,[r1,#0]
;;;290    }
0000d2  bd70              POP      {r4-r6,pc}
;;;291    void Class_Send_Max_Lun( void)      							// bRequest = 0xFE        
                          ENDP

                  |L3.212|
                          DCD      usb_running_ctrl_state
                  |L3.216|
                          DCD      ctrl_buf_ix
                  |L3.220|
0000dc  73657420          DCB      "set up",187,241,200,161,195,232,202,246,183,251,"\n\r",0
0000e0  7570bbf1
0000e4  c8a1c3e8
0000e8  caf6b7fb
0000ec  0a0d00  
0000ef  00                DCB      0
                  |L3.240|
0000f0  d0b4c8eb          DCB      208,180,200,235,187,186,179,229,199,248,163,186,0
0000f4  bbbab3e5
0000f8  c7f8a3ba
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L3.256|
                          DCD      wLength
                  |L3.260|
                          DCD      0x40005d40
                  |L3.264|
                          DCD      p_ctrl_buf
                  |L3.268|
00010c  25782000          DCB      "%x ",0
                  |L3.272|
000110  0d0a00            DCB      "\r\n",0
000113  00                DCB      0
                  |L3.276|
                          DCD      usb_state

                          AREA ||i.Chap9_GetInterface||, CODE, READONLY, ALIGN=2

                  Chap9_GetInterface PROC
;;;482    
;;;483    void Chap9_GetInterface( void)									//0x0a
000000  b510              PUSH     {r4,lr}
;;;484    {
;;;485        if(req_dir == USB_REQ_DIR_IN)
000002  4803              LDR      r0,|L4.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  2880              CMP      r0,#0x80
000008  d101              BNE      |L4.14|
;;;486        {
;;;487            EP0_Send_Empty_Packet();
00000a  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L4.14|
;;;488        }
;;;489        else
;;;490        {
;;;491            
;;;492        }
;;;493    }
00000e  bd10              POP      {r4,pc}
;;;494    void Chap9_SetInterface( void)									//0x0b
                          ENDP

                  |L4.16|
                          DCD      req_dir

                          AREA ||i.Chap9_GetStatus||, CODE, READONLY, ALIGN=2

                  Chap9_GetStatus PROC
;;;332    
;;;333    void Chap9_GetStatus( void)         							// 0x00
000000  481b              LDR      r0,|L5.112|
;;;334    {
;;;335        switch( usb_running_ctrl_state )
000002  7800              LDRB     r0,[r0,#0]  ; usb_running_ctrl_state
000004  b110              CBZ      r0,|L5.12|
000006  2801              CMP      r0,#1
000008  d12c              BNE      |L5.100|
00000a  e003              B        |L5.20|
                  |L5.12|
;;;336        {
;;;337        case    USB_CTRL_SETUP :
;;;338            {
;;;339                usb_running_ctrl_state = USB_CTRL_IN;
00000c  2001              MOVS     r0,#1
00000e  4918              LDR      r1,|L5.112|
000010  7008              STRB     r0,[r1,#0]
;;;340                break;
000012  e02b              B        |L5.108|
                  |L5.20|
;;;341            }
;;;342        case USB_CTRL_IN:
;;;343            {
;;;344                if(req_dir == USB_REQ_DIR_IN)
000014  4817              LDR      r0,|L5.116|
000016  7800              LDRB     r0,[r0,#0]  ; req_dir
000018  2880              CMP      r0,#0x80
00001a  d11f              BNE      |L5.92|
;;;345                {
;;;346                    if(req_recip==USB_REQ_RECIP_EP)
00001c  4816              LDR      r0,|L5.120|
00001e  7800              LDRB     r0,[r0,#0]  ; req_recip
000020  2802              CMP      r0,#2
000022  d10a              BNE      |L5.58|
;;;347                    {		
;;;348                        char ep = wIndex & 0x0F;
000024  4915              LDR      r1,|L5.124|
000026  8809              LDRH     r1,[r1,#0]  ; wIndex
000028  f001000f          AND      r0,r1,#0xf
;;;349                        
;;;350                        USB->rEP0_FIFO = USB_EP_STALL[ep];
00002c  4914              LDR      r1,|L5.128|
00002e  5c09              LDRB     r1,[r1,r0]
000030  4a14              LDR      r2,|L5.132|
000032  6011              STR      r1,[r2,#0]
;;;351                        USB->rEP0_FIFO = 0x00;
000034  2100              MOVS     r1,#0
000036  6011              STR      r1,[r2,#0]
;;;352                    }
000038  e00c              B        |L5.84|
                  |L5.58|
;;;353                    else if(req_recip==USB_REQ_RECIP_DEV)
00003a  480f              LDR      r0,|L5.120|
00003c  7800              LDRB     r0,[r0,#0]  ; req_recip
00003e  b928              CBNZ     r0,|L5.76|
;;;354                    {
;;;355                        
;;;356                        USB->rEP0_FIFO = 0x02;
000040  2002              MOVS     r0,#2
000042  4910              LDR      r1,|L5.132|
000044  6008              STR      r0,[r1,#0]
;;;357                        USB->rEP0_FIFO = 0x00;
000046  2000              MOVS     r0,#0
000048  6008              STR      r0,[r1,#0]
00004a  e003              B        |L5.84|
                  |L5.76|
;;;358                    }
;;;359                    else
;;;360                    {					
;;;361                        USB->rEP0_FIFO = 0x00;
00004c  2000              MOVS     r0,#0
00004e  490d              LDR      r1,|L5.132|
000050  6008              STR      r0,[r1,#0]
;;;362                        USB->rEP0_FIFO = 0x00;
000052  6008              STR      r0,[r1,#0]
                  |L5.84|
;;;363                    }			
;;;364                    USB->rEP0_CTRL = 0x82;
000054  2082              MOVS     r0,#0x82
000056  490b              LDR      r1,|L5.132|
000058  3920              SUBS     r1,r1,#0x20
00005a  6008              STR      r0,[r1,#0]
                  |L5.92|
;;;365                }		
;;;366                else
;;;367                {
;;;368                    
;;;369                }
;;;370                usb_running_ctrl_state = USB_IDLE;
00005c  20ff              MOVS     r0,#0xff
00005e  4904              LDR      r1,|L5.112|
000060  7008              STRB     r0,[r1,#0]
;;;371                break;				
000062  e003              B        |L5.108|
                  |L5.100|
;;;372            }
;;;373        default :
;;;374            {
;;;375                usb_running_ctrl_state = USB_IDLE ;
000064  20ff              MOVS     r0,#0xff
000066  4902              LDR      r1,|L5.112|
000068  7008              STRB     r0,[r1,#0]
;;;376                break ;
00006a  bf00              NOP      
                  |L5.108|
00006c  bf00              NOP                            ;340
;;;377            }
;;;378        }
;;;379    }
00006e  4770              BX       lr
;;;380    
                          ENDP

                  |L5.112|
                          DCD      usb_running_ctrl_state
                  |L5.116|
                          DCD      req_dir
                  |L5.120|
                          DCD      req_recip
                  |L5.124|
                          DCD      wIndex
                  |L5.128|
                          DCD      USB_EP_STALL
                  |L5.132|
                          DCD      0x40005d60

                          AREA ||i.Chap9_SetAddress||, CODE, READONLY, ALIGN=2

                  Chap9_SetAddress PROC
;;;149    }
;;;150    void Chap9_SetAddress( void)	    							//0x05
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152        if(req_dir == USB_REQ_DIR_OUT)
000002  4806              LDR      r0,|L6.28|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  b938              CBNZ     r0,|L6.24|
;;;153        {
;;;154            EP0_Send_Empty_Packet();	
000008  f7fffffe          BL       EP0_Send_Empty_Packet
;;;155            usb_state = USB_STATE_ADDRESS;
00000c  2003              MOVS     r0,#3
00000e  4904              LDR      r1,|L6.32|
000010  7008              STRB     r0,[r1,#0]
;;;156            printf("设置地址\r\n");
000012  a004              ADR      r0,|L6.36|
000014  f7fffffe          BL       __2printf
                  |L6.24|
;;;157        }
;;;158        else
;;;159        {
;;;160            
;;;161        }
;;;162    }
000018  bd10              POP      {r4,pc}
;;;163    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      req_dir
                  |L6.32|
                          DCD      usb_state
                  |L6.36|
000024  c9e8d6c3          DCB      201,232,214,195,181,216,214,183,"\r\n",0
000028  b5d8d6b7
00002c  0d0a00  
00002f  00                DCB      0

                          AREA ||i.Chap9_SetConfiguration||, CODE, READONLY, ALIGN=2

                  Chap9_SetConfiguration PROC
;;;138    //=========================== Each Request =============================
;;;139    void Chap9_SetConfiguration( void)								//0x09
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141        if(req_dir == USB_REQ_DIR_OUT)
000002  4803              LDR      r0,|L7.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  b908              CBNZ     r0,|L7.12|
;;;142        {
;;;143            EP0_Send_Empty_Packet();
000008  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L7.12|
;;;144        }
;;;145        else
;;;146        {
;;;147            
;;;148        }
;;;149    }
00000c  bd10              POP      {r4,pc}
;;;150    void Chap9_SetAddress( void)	    							//0x05
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      req_dir

                          AREA ||i.Chap9_SetDescriptor||, CODE, READONLY, ALIGN=2

                  Chap9_SetDescriptor PROC
;;;459    
;;;460    void Chap9_SetDescriptor( void)     							//0x07
000000  b510              PUSH     {r4,lr}
;;;461    {
;;;462        if(req_dir == USB_REQ_DIR_OUT)
000002  4803              LDR      r0,|L8.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  b908              CBNZ     r0,|L8.12|
;;;463        {
;;;464            EP0_Send_Empty_Packet();
000008  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L8.12|
;;;465        }
;;;466        else
;;;467        {
;;;468            
;;;469        }
;;;470    }
00000c  bd10              POP      {r4,pc}
;;;471    void Chap9_GetConfiguration( void)								//0x08
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      req_dir

                          AREA ||i.Chap9_SetFeature||, CODE, READONLY, ALIGN=2

                  Chap9_SetFeature PROC
;;;447    }
;;;448    void Chap9_SetFeature( void)	    							// 0x03
000000  b510              PUSH     {r4,lr}
;;;449    {
;;;450        if(req_dir == USB_REQ_DIR_OUT)
000002  4803              LDR      r0,|L9.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  b908              CBNZ     r0,|L9.12|
;;;451        {
;;;452            EP0_Send_Empty_Packet();
000008  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L9.12|
;;;453        }
;;;454        else
;;;455        {
;;;456            
;;;457        }
;;;458    }
00000c  bd10              POP      {r4,pc}
;;;459    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      req_dir

                          AREA ||i.Chap9_SetInterface||, CODE, READONLY, ALIGN=2

                  Chap9_SetInterface PROC
;;;493    }
;;;494    void Chap9_SetInterface( void)									//0x0b
000000  b510              PUSH     {r4,lr}
;;;495    {
;;;496        if(req_dir == USB_REQ_DIR_OUT)
000002  4803              LDR      r0,|L10.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  b908              CBNZ     r0,|L10.12|
;;;497        {
;;;498            EP0_Send_Empty_Packet();
000008  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L10.12|
;;;499        }
;;;500        else
;;;501        {
;;;502            
;;;503        }
;;;504    }
00000c  bd10              POP      {r4,pc}
;;;505    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      req_dir

                          AREA ||i.Class_Send_Max_Lun||, CODE, READONLY, ALIGN=2

                  Class_Send_Max_Lun PROC
;;;290    }
;;;291    void Class_Send_Max_Lun( void)      							// bRequest = 0xFE        
000000  4814              LDR      r0,|L11.84|
;;;292    {
;;;293        switch( usb_running_ctrl_state )
000002  7800              LDRB     r0,[r0,#0]  ; usb_running_ctrl_state
000004  b110              CBZ      r0,|L11.12|
000006  2801              CMP      r0,#1
000008  d11d              BNE      |L11.70|
00000a  e00b              B        |L11.36|
                  |L11.12|
;;;294        {
;;;295        case    USB_CTRL_SETUP :
;;;296            {
;;;297                if(req_dir == USB_REQ_DIR_IN)
00000c  4812              LDR      r0,|L11.88|
00000e  7800              LDRB     r0,[r0,#0]  ; req_dir
000010  2880              CMP      r0,#0x80
000012  d103              BNE      |L11.28|
;;;298                    usb_running_ctrl_state = USB_CTRL_IN;
000014  2001              MOVS     r0,#1
000016  490f              LDR      r1,|L11.84|
000018  7008              STRB     r0,[r1,#0]
00001a  e002              B        |L11.34|
                  |L11.28|
;;;299                else
;;;300                    usb_running_ctrl_state = USB_IDLE;
00001c  20ff              MOVS     r0,#0xff
00001e  490d              LDR      r1,|L11.84|
000020  7008              STRB     r0,[r1,#0]
                  |L11.34|
;;;301                break ;
000022  e014              B        |L11.78|
                  |L11.36|
;;;302            }
;;;303        case    USB_CTRL_IN :
;;;304            {
;;;305                
;;;306    #ifdef USB_EP_STALL_TEST
;;;307                {
;;;308                    USB->rEP_HALT = 0X01;
;;;309    #ifndef SCC5_VER_0302				
;;;310                    USB->rEP0_CTRL = 0X80;
;;;311    #endif
;;;312                    USB_SEND_OPEN_STALL[0] = TRUE;
;;;313                }
;;;314    #else
;;;315                {
;;;316                    while(USB->rEP0_CTRL&0x80);
000024  bf00              NOP      
                  |L11.38|
000026  480d              LDR      r0,|L11.92|
000028  6800              LDR      r0,[r0,#0]
00002a  f0000080          AND      r0,r0,#0x80
00002e  2800              CMP      r0,#0
000030  d1f9              BNE      |L11.38|
;;;317                    USB->rEP0_FIFO = 0;
000032  490a              LDR      r1,|L11.92|
000034  3120              ADDS     r1,r1,#0x20
000036  6008              STR      r0,[r1,#0]
;;;318                    USB->rEP0_CTRL = 0x81;
000038  2081              MOVS     r0,#0x81
00003a  4908              LDR      r1,|L11.92|
00003c  6008              STR      r0,[r1,#0]
;;;319                }
;;;320    #endif
;;;321                usb_running_ctrl_state = USB_IDLE;  
00003e  20ff              MOVS     r0,#0xff
000040  4904              LDR      r1,|L11.84|
000042  7008              STRB     r0,[r1,#0]
;;;322                break ;
000044  e003              B        |L11.78|
                  |L11.70|
;;;323            }		
;;;324        default :
;;;325            {
;;;326                usb_running_ctrl_state = USB_IDLE ;
000046  20ff              MOVS     r0,#0xff
000048  4902              LDR      r1,|L11.84|
00004a  7008              STRB     r0,[r1,#0]
;;;327                break ;
00004c  bf00              NOP      
                  |L11.78|
00004e  bf00              NOP                            ;301
;;;328            }
;;;329        } 
;;;330    }
000050  4770              BX       lr
;;;331    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      usb_running_ctrl_state
                  |L11.88|
                          DCD      req_dir
                  |L11.92|
                          DCD      0x40005d40

                          AREA ||i.EP0_Send_Empty_Packet||, CODE, READONLY, ALIGN=2

                  EP0_Send_Empty_Packet PROC
;;;506    
;;;507    void EP0_Send_Empty_Packet()
000000  b510              PUSH     {r4,lr}
;;;508    {
;;;509        printf("发送空数据\r\n");
000002  a010              ADR      r0,|L12.68|
000004  f7fffffe          BL       __2printf
;;;510        switch( usb_running_ctrl_state )
000008  4812              LDR      r0,|L12.84|
00000a  7800              LDRB     r0,[r0,#0]  ; usb_running_ctrl_state
00000c  b110              CBZ      r0,|L12.20|
00000e  2801              CMP      r0,#1
000010  d112              BNE      |L12.56|
000012  e003              B        |L12.28|
                  |L12.20|
;;;511        {
;;;512        case    USB_CTRL_SETUP :
;;;513            {
;;;514                usb_running_ctrl_state = USB_CTRL_IN;
000014  2001              MOVS     r0,#1
000016  490f              LDR      r1,|L12.84|
000018  7008              STRB     r0,[r1,#0]
;;;515                break ;
00001a  e011              B        |L12.64|
                  |L12.28|
;;;516            }
;;;517        case    USB_CTRL_IN :
;;;518            {
;;;519                
;;;520                while(USB->rEP0_CTRL&0x80);
00001c  bf00              NOP      
                  |L12.30|
00001e  480e              LDR      r0,|L12.88|
000020  6800              LDR      r0,[r0,#0]
000022  f0000080          AND      r0,r0,#0x80
000026  2800              CMP      r0,#0
000028  d1f9              BNE      |L12.30|
;;;521                USB->rEP0_CTRL = 0x80;
00002a  2080              MOVS     r0,#0x80
00002c  490a              LDR      r1,|L12.88|
00002e  6008              STR      r0,[r1,#0]
;;;522                usb_running_ctrl_state = USB_IDLE; 
000030  20ff              MOVS     r0,#0xff
000032  4908              LDR      r1,|L12.84|
000034  7008              STRB     r0,[r1,#0]
;;;523                break ;
000036  e003              B        |L12.64|
                  |L12.56|
;;;524            }		
;;;525        default :
;;;526            {
;;;527                usb_running_ctrl_state = USB_IDLE ;
000038  20ff              MOVS     r0,#0xff
00003a  4906              LDR      r1,|L12.84|
00003c  7008              STRB     r0,[r1,#0]
;;;528                break ;
00003e  bf00              NOP      
                  |L12.64|
000040  bf00              NOP                            ;515
;;;529            }
;;;530        } 
;;;531    }
000042  bd10              POP      {r4,pc}
;;;532    
                          ENDP

                  |L12.68|
000044  b7a2cbcd          DCB      183,162,203,205,191,213,202,253,190,221,"\r\n",0
000048  bfd5cafd
00004c  bedd0d0a
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L12.84|
                          DCD      usb_running_ctrl_state
                  |L12.88|
                          DCD      0x40005d40

                          AREA ||i.Get_Desc_Prepare||, CODE, READONLY, ALIGN=2

                  Get_Desc_Prepare PROC
;;;163    
;;;164    void Get_Desc_Prepare( void)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
;;;166        uint32 type = wValue & 0xFF00;
000002  4838              LDR      r0,|L13.228|
000004  8800              LDRH     r0,[r0,#0]  ; wValue
000006  f400457f          AND      r5,r0,#0xff00
;;;167        uint32 index = wValue & 0x00FF;
00000a  4836              LDR      r0,|L13.228|
00000c  8800              LDRH     r0,[r0,#0]  ; wValue
00000e  b2c4              UXTB     r4,r0
;;;168        switch(type)
000010  f5b57f80          CMP      r5,#0x100
000014  d009              BEQ      |L13.42|
000016  f5b57f00          CMP      r5,#0x200
00001a  d014              BEQ      |L13.70|
00001c  f5b57f40          CMP      r5,#0x300
000020  d01f              BEQ      |L13.98|
000022  f5b55f08          CMP      r5,#0x2200
000026  d157              BNE      |L13.216|
000028  e048              B        |L13.188|
                  |L13.42|
;;;169        {
;;;170        case    DEVICE_DESC_TYPE :
;;;171            {  	
;;;172                if( wLength > DeviceDescLen )   wLength = DeviceDescLen ;
00002a  482f              LDR      r0,|L13.232|
00002c  8800              LDRH     r0,[r0,#0]  ; wLength
00002e  2812              CMP      r0,#0x12
000030  d902              BLS      |L13.56|
000032  2012              MOVS     r0,#0x12
000034  492c              LDR      r1,|L13.232|
000036  8008              STRH     r0,[r1,#0]
                  |L13.56|
;;;173                p_ctrl_buf = DeviceDesc ;
000038  482c              LDR      r0,|L13.236|
00003a  492d              LDR      r1,|L13.240|
00003c  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;174                
;;;175                printf("获取设备描述符\r\n");
00003e  a02d              ADR      r0,|L13.244|
000040  f7fffffe          BL       __2printf
;;;176                
;;;177                break ;
000044  e04c              B        |L13.224|
                  |L13.70|
;;;178            }
;;;179        case    CONFIGURATION_DESC_TYPE :
;;;180            {
;;;181                if( wLength > ConfigDescLen )   wLength = ConfigDescLen ;
000046  4828              LDR      r0,|L13.232|
000048  8800              LDRH     r0,[r0,#0]  ; wLength
00004a  2822              CMP      r0,#0x22
00004c  d902              BLS      |L13.84|
00004e  2022              MOVS     r0,#0x22
000050  4925              LDR      r1,|L13.232|
000052  8008              STRH     r0,[r1,#0]
                  |L13.84|
;;;182                p_ctrl_buf = ConfigDesc ;
000054  482c              LDR      r0,|L13.264|
000056  4926              LDR      r1,|L13.240|
000058  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;183                printf("获取配置描述符\r\n");
00005a  a02c              ADR      r0,|L13.268|
00005c  f7fffffe          BL       __2printf
;;;184                break ;
000060  e03e              B        |L13.224|
                  |L13.98|
;;;185            }
;;;186        case    STRING_DESC_TYPE :
;;;187            {
;;;188                if( index < 4 )
000062  2c04              CMP      r4,#4
000064  d226              BCS      |L13.180|
;;;189                {
;;;190                    if( wLength > StrDescLenGroup[index] )   
000066  482e              LDR      r0,|L13.288|
000068  5d00              LDRB     r0,[r0,r4]
00006a  491f              LDR      r1,|L13.232|
00006c  8809              LDRH     r1,[r1,#0]  ; wLength
00006e  4288              CMP      r0,r1
000070  da03              BGE      |L13.122|
;;;191                        wLength = StrDescLenGroup[index] ;
000072  482b              LDR      r0,|L13.288|
000074  5d00              LDRB     r0,[r0,r4]
000076  491c              LDR      r1,|L13.232|
000078  8008              STRH     r0,[r1,#0]
                  |L13.122|
;;;192                    switch(index)
00007a  b134              CBZ      r4,|L13.138|
00007c  2c01              CMP      r4,#1
00007e  d008              BEQ      |L13.146|
000080  2c02              CMP      r4,#2
000082  d00a              BEQ      |L13.154|
000084  2c03              CMP      r4,#3
000086  d110              BNE      |L13.170|
000088  e00b              B        |L13.162|
                  |L13.138|
;;;193                    {
;;;194                    case 0:
;;;195                        p_ctrl_buf = Str0Desc;
00008a  4826              LDR      r0,|L13.292|
00008c  4918              LDR      r1,|L13.240|
00008e  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;196                        break;
000090  e00b              B        |L13.170|
                  |L13.146|
;;;197                    case 1:
;;;198                        p_ctrl_buf = Str1Desc;
000092  4825              LDR      r0,|L13.296|
000094  4916              LDR      r1,|L13.240|
000096  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;199                        break;
000098  e007              B        |L13.170|
                  |L13.154|
;;;200                    case 2:
;;;201                        p_ctrl_buf = Str2Desc;
00009a  4824              LDR      r0,|L13.300|
00009c  4914              LDR      r1,|L13.240|
00009e  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;202                        break;
0000a0  e003              B        |L13.170|
                  |L13.162|
;;;203                    case 3:
;;;204                        p_ctrl_buf = Str3Desc;
0000a2  4823              LDR      r0,|L13.304|
0000a4  4912              LDR      r1,|L13.240|
0000a6  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;205                        break;
0000a8  bf00              NOP      
                  |L13.170|
0000aa  bf00              NOP                            ;196
;;;206                    }
;;;207                    printf("获取字符串描述符\r\n");
0000ac  a021              ADR      r0,|L13.308|
0000ae  f7fffffe          BL       __2printf
0000b2  e002              B        |L13.186|
                  |L13.180|
;;;208                }
;;;209                else
;;;210                {
;;;211                    wLength = 0 ;
0000b4  2000              MOVS     r0,#0
0000b6  490c              LDR      r1,|L13.232|
0000b8  8008              STRH     r0,[r1,#0]
                  |L13.186|
;;;212                }
;;;213                break ;
0000ba  e011              B        |L13.224|
                  |L13.188|
;;;214            }
;;;215    #ifdef DEVICE_HID		
;;;216        case HID_REPORT_TYPE:  									// class des
;;;217            {
;;;218                if( wLength > ConfigDescLen )   wLength = InterfaceDesLen;
0000bc  480a              LDR      r0,|L13.232|
0000be  8800              LDRH     r0,[r0,#0]  ; wLength
0000c0  2822              CMP      r0,#0x22
0000c2  d902              BLS      |L13.202|
0000c4  2041              MOVS     r0,#0x41
0000c6  4908              LDR      r1,|L13.232|
0000c8  8008              STRH     r0,[r1,#0]
                  |L13.202|
;;;219                p_ctrl_buf = IntefaceDes;
0000ca  481f              LDR      r0,|L13.328|
0000cc  4908              LDR      r1,|L13.240|
0000ce  6008              STR      r0,[r1,#0]  ; p_ctrl_buf
;;;220                printf("返回HID报告\r\n");
0000d0  a01e              ADR      r0,|L13.332|
0000d2  f7fffffe          BL       __2printf
;;;221                break;
0000d6  e003              B        |L13.224|
                  |L13.216|
;;;222            }
;;;223    #endif		
;;;224        default :
;;;225            {
;;;226                wLength = 0 ;
0000d8  2000              MOVS     r0,#0
0000da  4903              LDR      r1,|L13.232|
0000dc  8008              STRH     r0,[r1,#0]
;;;227                break ;
0000de  bf00              NOP      
                  |L13.224|
0000e0  bf00              NOP                            ;177
;;;228            }
;;;229        }
;;;230    }
0000e2  bd70              POP      {r4-r6,pc}
;;;231    void Chap9_GetDescriptor( void)     							//0x06
                          ENDP

                  |L13.228|
                          DCD      wValue
                  |L13.232|
                          DCD      wLength
                  |L13.236|
                          DCD      DeviceDesc
                  |L13.240|
                          DCD      p_ctrl_buf
                  |L13.244|
0000f4  bbf1c8a1          DCB      187,241,200,161,201,232,177,184,195,232,202,246,183,251,"\r"
0000f8  c9e8b1b8
0000fc  c3e8caf6
000100  b7fb0d  
000103  0a00              DCB      "\n",0
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L13.264|
                          DCD      ConfigDesc
                  |L13.268|
00010c  bbf1c8a1          DCB      187,241,200,161,197,228,214,195,195,232,202,246,183,251,"\r"
000110  c5e4d6c3
000114  c3e8caf6
000118  b7fb0d  
00011b  0a00              DCB      "\n",0
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L13.288|
                          DCD      StrDescLenGroup
                  |L13.292|
                          DCD      Str0Desc
                  |L13.296|
                          DCD      Str1Desc
                  |L13.300|
                          DCD      Str2Desc
                  |L13.304|
                          DCD      Str3Desc
                  |L13.308|
000134  bbf1c8a1          DCB      187,241,200,161,215,214,183,251,180,174,195,232,202,246,183
000138  d7d6b7fb
00013c  b4aec3e8
000140  caf6b7  
000143  fb0d0a00          DCB      251,"\r\n",0
000147  00                DCB      0
                  |L13.328|
                          DCD      IntefaceDes
                  |L13.332|
00014c  b7b5bbd8          DCB      183,181,187,216,"HID",177,168,184,230,"\r\n",0
000150  484944b1
000154  a8b8e60d
000158  0a00    
00015a  00                DCB      0
00015b  00                DCB      0

                          AREA ||i.MLsup_StallEP0||, CODE, READONLY, ALIGN=2

                  MLsup_StallEP0 PROC
;;;425    }
;;;426    void MLsup_StallEP0( void)          							// reserve      0x02
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428        if(req_dir == USB_REQ_DIR_IN)
000002  4803              LDR      r0,|L14.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  2880              CMP      r0,#0x80
000008  d101              BNE      |L14.14|
;;;429        {
;;;430            EP0_Send_Empty_Packet();
00000a  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L14.14|
;;;431        }
;;;432        else
;;;433        {
;;;434            
;;;435        }
;;;436    }
00000e  bd10              POP      {r4,pc}
;;;437    void MLsup_StallEP1( void)          							// reserve      0x04
                          ENDP

                  |L14.16|
                          DCD      req_dir

                          AREA ||i.MLsup_StallEP1||, CODE, READONLY, ALIGN=2

                  MLsup_StallEP1 PROC
;;;436    }
;;;437    void MLsup_StallEP1( void)          							// reserve      0x04
000000  b510              PUSH     {r4,lr}
;;;438    {
;;;439        if(req_dir == USB_REQ_DIR_IN)
000002  4803              LDR      r0,|L15.16|
000004  7800              LDRB     r0,[r0,#0]  ; req_dir
000006  2880              CMP      r0,#0x80
000008  d101              BNE      |L15.14|
;;;440        {
;;;441            EP0_Send_Empty_Packet();
00000a  f7fffffe          BL       EP0_Send_Empty_Packet
                  |L15.14|
;;;442        }
;;;443        else
;;;444        {
;;;445            
;;;446        }
;;;447    }
00000e  bd10              POP      {r4,pc}
;;;448    void Chap9_SetFeature( void)	    							// 0x03
                          ENDP

                  |L15.16|
                          DCD      req_dir

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ctrl_buf
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  p_ctrl_buf
                          DCD      0x00000000
                  ctrl_count
000004  00                DCB      0x00
                  DeviceDesc
000005  120110            DCB      0x12,0x01,0x10
000008  01000000          DCB      0x01,0x00,0x00,0x00
00000c  40080806          DCB      0x40,0x08,0x08,0x06
000010  06000200          DCB      0x06,0x00,0x02,0x00
000014  020001            DCB      0x02,0x00,0x01
                  ConfigDesc
000017  09                DCB      0x09
000018  02220001          DCB      0x02,0x22,0x00,0x01
00001c  0100a032          DCB      0x01,0x00,0xa0,0x32
000020  09040000          DCB      0x09,0x04,0x00,0x00
000024  01030101          DCB      0x01,0x03,0x01,0x01
000028  00092110          DCB      0x00,0x09,0x21,0x10
00002c  01210122          DCB      0x01,0x21,0x01,0x22
000030  41000705          DCB      0x41,0x00,0x07,0x05
000034  81034000          DCB      0x81,0x03,0x40,0x00
000038  05                DCB      0x05
                  IntefaceDes
000039  050109            DCB      0x05,0x01,0x09
00003c  06a10105          DCB      0x06,0xa1,0x01,0x05
000040  0719e029          DCB      0x07,0x19,0xe0,0x29
000044  e7150025          DCB      0xe7,0x15,0x00,0x25
000048  01950875          DCB      0x01,0x95,0x08,0x75
00004c  01810295          DCB      0x01,0x81,0x02,0x95
000050  01750881          DCB      0x01,0x75,0x08,0x81
000054  03950675          DCB      0x03,0x95,0x06,0x75
000058  08150025          DCB      0x08,0x15,0x00,0x25
00005c  ff050719          DCB      0xff,0x05,0x07,0x19
000060  00296581          DCB      0x00,0x29,0x65,0x81
000064  00250195          DCB      0x00,0x25,0x01,0x95
000068  05750105          DCB      0x05,0x75,0x01,0x05
00006c  08190129          DCB      0x08,0x19,0x01,0x29
000070  05910295          DCB      0x05,0x91,0x02,0x95
000074  01750391          DCB      0x01,0x75,0x03,0x91
000078  03c0              DCB      0x03,0xc0
                  Str0Desc
00007a  0403              DCB      0x04,0x03
00007c  0904              DCB      0x09,0x04
                  Str1Desc
00007e  0403              DCB      0x04,0x03
000080  2000              DCB      0x20,0x00
                  Str2Desc
000082  2403              DCB      0x24,0x03
000084  55005300          DCB      0x55,0x00,0x53,0x00
000088  42002000          DCB      0x42,0x00,0x20,0x00
00008c  4f007000          DCB      0x4f,0x00,0x70,0x00
000090  74006900          DCB      0x74,0x00,0x69,0x00
000094  63006100          DCB      0x63,0x00,0x61,0x00
000098  6c002000          DCB      0x6c,0x00,0x20,0x00
00009c  4d006f00          DCB      0x4d,0x00,0x6f,0x00
0000a0  75007300          DCB      0x75,0x00,0x73,0x00
0000a4  6500              DCB      0x65,0x00
                  Str3Desc
0000a6  1603              DCB      0x16,0x03
0000a8  32003000          DCB      0x32,0x00,0x30,0x00
0000ac  32003700          DCB      0x32,0x00,0x37,0x00
0000b0  33003000          DCB      0x33,0x00,0x30,0x00
0000b4  30003400          DCB      0x30,0x00,0x34,0x00
0000b8  31003300          DCB      0x31,0x00,0x33,0x00
                  StrDescLenGroup
0000bc  04042416          DCB      0x04,0x04,0x24,0x16
                  ctrl_buf_ix
0000c0  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\bsp\\usblib\\ctrlitem.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ctrlitem_c_cae74fcb____REV16|
#line 129 "..\\..\\..\\..\\..\\Device\\CMSIS\\KEIL_CORE\\core_cmInstr.h"
|__asm___10_ctrlitem_c_cae74fcb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ctrlitem_c_cae74fcb____REVSH|
#line 144
|__asm___10_ctrlitem_c_cae74fcb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_ctrlitem_c_cae74fcb____RRX|
#line 300
|__asm___10_ctrlitem_c_cae74fcb____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
