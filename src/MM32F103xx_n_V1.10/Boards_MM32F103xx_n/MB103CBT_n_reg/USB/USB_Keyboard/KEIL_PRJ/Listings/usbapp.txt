; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\usbapp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usbapp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\bsp -I..\bsp\test -I..\bsp\usblib -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\uart -I..\..\..\..\..\Device\MM32F103\Include -I..\HARDWARE\KEY -I..\..\..\..\..\Device\CMSIS\KEIL_CORE -IF:\work\8月\F103n、F031n样例制作\MM32F103RegLib_MiniBoard_Ver1.0.0\MM32F103RegLib_MiniBoard_libReg\MBF103PF_reg\USB\USB_Keyboard\KEIL_PRJ\RTE\_projectgroup -IC:\Keil_v5\ARM\PACK\MindMotion\MM32F103_DFP\1.4.3\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\MindMotion\MM32L3xx_DFP\1.0.3\Device\MM32L3xx\Include -D__UVISION_VERSION=522 -DMM32F103CBT -DF103_N_VERSION --omf_browse=.\objects\usbapp.crf ..\bsp\test\usbapp.c]
                          THUMB

                          AREA ||i.USB_GPIO||, CODE, READONLY, ALIGN=2

                  USB_GPIO PROC
;;;10     ********************************************************************************************************/
;;;11     void USB_GPIO(void)
000000  480b              LDR      r0,|L1.48|
;;;12     {
;;;13         RCC->APB2ENR|=RCC_APB2RSTR_IOPARST;   //RCC->APB2ENR|=1<<2;  //使能GPIOA时钟	   	 
000002  6980              LDR      r0,[r0,#0x18]
000004  f0400004          ORR      r0,r0,#4
000008  4909              LDR      r1,|L1.48|
00000a  6188              STR      r0,[r1,#0x18]
;;;14         GPIOA->CRH&=0XFFF00FFF;
00000c  4809              LDR      r0,|L1.52|
00000e  6800              LDR      r0,[r0,#0]
000010  f420207f          BIC      r0,r0,#0xff000
000014  4907              LDR      r1,|L1.52|
000016  6008              STR      r0,[r1,#0]
;;;15         GPIOA->CRL|=GPIO_CRL_MODE5;
000018  1f08              SUBS     r0,r1,#4
00001a  6800              LDR      r0,[r0,#0]
00001c  f4401040          ORR      r0,r0,#0x300000
000020  1f09              SUBS     r1,r1,#4
000022  6008              STR      r0,[r1,#0]
;;;16         GPIOA->BRR = 0x0020;
000024  2020              MOVS     r0,#0x20
000026  4903              LDR      r1,|L1.52|
000028  3110              ADDS     r1,r1,#0x10
00002a  6008              STR      r0,[r1,#0]
;;;17     }
00002c  4770              BX       lr
;;;18     /********************************************************************************************************
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40021000
                  |L1.52|
                          DCD      0x40010804

                          AREA ||i.keyBoard_ctrl||, CODE, READONLY, ALIGN=2

                  keyBoard_ctrl PROC
;;;114    ********************************************************************************************************/
;;;115    void keyBoard_ctrl(char spcKey,char nomKey0,char nomKey1,char nomKey2,
000000  e92d47fe          PUSH     {r1-r10,lr}
;;;116                       char nomKey3,char nomKey4,char nomKey5)
;;;117    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
000010  f8dd802c          LDR      r8,[sp,#0x2c]
;;;118        keyBoard_value(spcKey,nomKey0,nomKey1,nomKey2,nomKey3,nomKey4,nomKey5);	//键值写入缓冲寄存器
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  e88d0700          STM      sp,{r8-r10}
000020  f7fffffe          BL       keyBoard_value
;;;119        
;;;120        while(USB->rEP1_CTRL&0x80);
000024  bf00              NOP      
                  |L2.38|
000026  480b              LDR      r0,|L2.84|
000028  6800              LDR      r0,[r0,#0]
00002a  f0000080          AND      r0,r0,#0x80
00002e  2800              CMP      r0,#0
000030  d1f9              BNE      |L2.38|
;;;121        keyBoard_value(KEY_NONE,KEY_NONE,KEY_NONE,KEY_NONE,KEY_NONE,KEY_NONE,KEY_NONE);//清键值
000032  9000              STR      r0,[sp,#0]
000034  9001              STR      r0,[sp,#4]
000036  4603              MOV      r3,r0
000038  4602              MOV      r2,r0
00003a  4601              MOV      r1,r0
00003c  9002              STR      r0,[sp,#8]
00003e  f7fffffe          BL       keyBoard_value
;;;122        
;;;123        while(USB->rEP1_CTRL&0x80);
000042  bf00              NOP      
                  |L2.68|
000044  4803              LDR      r0,|L2.84|
000046  6800              LDR      r0,[r0,#0]
000048  f0000080          AND      r0,r0,#0x80
00004c  2800              CMP      r0,#0
00004e  d1f9              BNE      |L2.68|
;;;124    }
000050  e8bd87fe          POP      {r1-r10,pc}
;;;125    
                          ENDP

                  |L2.84|
                          DCD      0x40005d44

                          AREA ||i.keyBoard_value||, CODE, READONLY, ALIGN=2

                  keyBoard_value PROC
;;;94     ********************************************************************************************************/
;;;95     void keyBoard_value(char spcKey,char nomKey0,char nomKey1,char nomKey2,
000000  b5f0              PUSH     {r4-r7,lr}
;;;96                         char nomKey3,char nomKey4,char nomKey5) 	
;;;97     {
000002  ac05              ADD      r4,sp,#0x14
000004  cc70              LDM      r4,{r4-r6}
;;;98         USB->rEP1_FIFO = spcKey;					//功能键
000006  4f0b              LDR      r7,|L3.52|
000008  6038              STR      r0,[r7,#0]
;;;99         USB->rEP1_FIFO = 0;							//保留
00000a  2700              MOVS     r7,#0
00000c  f8dfc024          LDR      r12,|L3.52|
000010  f8cc7000          STR      r7,[r12,#0]
;;;100        USB->rEP1_FIFO = nomKey0;					//常用按键键值,按键1为0x59 数字依次类推
000014  4667              MOV      r7,r12
000016  6039              STR      r1,[r7,#0]
;;;101        USB->rEP1_FIFO = nomKey1;					//常用按键键值
000018  603a              STR      r2,[r7,#0]
;;;102        USB->rEP1_FIFO = nomKey2;					//常用按键键值
00001a  603b              STR      r3,[r7,#0]
;;;103        USB->rEP1_FIFO = nomKey3;
00001c  603c              STR      r4,[r7,#0]
;;;104        USB->rEP1_FIFO = nomKey4;
00001e  603d              STR      r5,[r7,#0]
;;;105        USB->rEP1_FIFO = nomKey5;
000020  603e              STR      r6,[r7,#0]
;;;106        USB->rEP1_CTRL = 0x88;						//send 8 bytes packet	
000022  2788              MOVS     r7,#0x88
000024  f8dfc00c          LDR      r12,|L3.52|
000028  f1ac0c20          SUB      r12,r12,#0x20
00002c  f8cc7000          STR      r7,[r12,#0]
;;;107    }
000030  bdf0              POP      {r4-r7,pc}
;;;108    /********************************************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x40005d64

                          AREA ||i.mouse_ctrl||, CODE, READONLY, ALIGN=2

                  mouse_ctrl PROC
;;;59     ********************************************************************************************************/
;;;60     void mouse_ctrl(char clickEnt,char x,char y,char rol) 
000000  b530              PUSH     {r4,r5,lr}
;;;61     {
;;;62         USB->rEP1_FIFO = clickEnt;									//单击事件
000002  4c05              LDR      r4,|L4.24|
000004  6020              STR      r0,[r4,#0]
;;;63         USB->rEP1_FIFO = x;											//x坐标相对移动位置 (-128~127)
000006  6021              STR      r1,[r4,#0]
;;;64         USB->rEP1_FIFO = y;											//y坐标相对移动位置 (-128~127)
000008  6022              STR      r2,[r4,#0]
;;;65         USB->rEP1_FIFO = rol;										//滚轮相对移动位置 (-128~127)
00000a  6023              STR      r3,[r4,#0]
;;;66         USB->rEP1_CTRL = 0x84;										//send 4 bytes packet	
00000c  2484              MOVS     r4,#0x84
00000e  4d02              LDR      r5,|L4.24|
000010  3d20              SUBS     r5,r5,#0x20
000012  602c              STR      r4,[r5,#0]
;;;67     }
000014  bd30              POP      {r4,r5,pc}
;;;68     
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x40005d64

                          AREA ||i.usb_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  usb_test PROC
;;;23     ********************************************************************************************************/
;;;24     void usb_test(void)
000000  b510              PUSH     {r4,lr}
;;;25     {
;;;26         //	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB,ENABLE); 				//USB CLK EN
;;;27         RCC->APB1ENR|=RCC_APB1ENR_USBEN;
000002  480c              LDR      r0,|L5.52|
000004  69c0              LDR      r0,[r0,#0x1c]
000006  f4400000          ORR      r0,r0,#0x800000
00000a  490a              LDR      r1,|L5.52|
00000c  61c8              STR      r0,[r1,#0x1c]
;;;28         printf("This is a USB Demo \r\n");
00000e  a00a              ADR      r0,|L5.56|
000010  f7fffffe          BL       __2printf
;;;29         
;;;30         USB_GPIO();
000014  f7fffffe          BL       USB_GPIO
;;;31     #ifdef USB_INTR_MODE
;;;32         //	NVIC_InitStructure.NVIC_IRQChannel = USB_HP_CAN1_TX_IRQn;		//配置USB中断向量
;;;33         //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;34         //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
;;;35         //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;36         //	NVIC_Init(&NVIC_InitStructure);
;;;37         MY_NVIC_Init(0,1,USB_HP_CAN1_TX_IRQn,0);//组2，最低优先级 
000018  2300              MOVS     r3,#0
00001a  2213              MOVS     r2,#0x13
00001c  2101              MOVS     r1,#1
00001e  4618              MOV      r0,r3
000020  f7fffffe          BL       MY_NVIC_Init
;;;38         
;;;39     #endif
;;;40         USB_Init();
000024  f7fffffe          BL       USB_Init
;;;41         printf("This is %x \r\n",*(u32*)0x40010804);
000028  4809              LDR      r0,|L5.80|
00002a  6801              LDR      r1,[r0,#0]
00002c  a009              ADR      r0,|L5.84|
00002e  f7fffffe          BL       __2printf
;;;42     }
000032  bd10              POP      {r4,pc}
;;;43     
                          ENDP

                  |L5.52|
                          DCD      0x40021000
                  |L5.56|
000038  54686973          DCB      "This is a USB Demo \r\n",0
00003c  20697320
000040  61205553
000044  42204465
000048  6d6f200d
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L5.80|
                          DCD      0x40010804
                  |L5.84|
000054  54686973          DCB      "This is %x \r\n",0
000058  20697320
00005c  2578200d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

;*** Start embedded assembler ***

#line 1 "..\\bsp\\test\\usbapp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_usbapp_c_USB_GPIO____REV16|
#line 129 "..\\..\\..\\..\\..\\Device\\CMSIS\\KEIL_CORE\\core_cmInstr.h"
|__asm___8_usbapp_c_USB_GPIO____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_usbapp_c_USB_GPIO____REVSH|
#line 144
|__asm___8_usbapp_c_USB_GPIO____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_usbapp_c_USB_GPIO____RRX|
#line 300
|__asm___8_usbapp_c_USB_GPIO____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
